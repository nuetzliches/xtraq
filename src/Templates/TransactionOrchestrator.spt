{{ HEADER }}
#nullable enable
namespace {{ Namespace }};

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public interface IXtraqTransactionOrchestrator
{
    bool HasActiveTransaction { get; }
    DbConnection? CurrentConnection { get; }
    DbTransaction? CurrentTransaction { get; }
    ValueTask<XtraqTransactionScope> BeginAsync(XtraqTransactionOptions? options = null, CancellationToken cancellationToken = default);
}

public sealed record class XtraqTransactionOptions
{
    public IsolationLevel? IsolationLevel { get; init; }
    public bool RequiresNew { get; init; }
    public static XtraqTransactionOptions Default { get; } = new();
}

public sealed class XtraqTransactionOrchestrator : IXtraqTransactionOrchestrator
{
    private readonly IXtraqDbContext _dbContext;
    private readonly SemaphoreSlim _gate = new(1, 1);
    private readonly Stack<XtraqTransactionScopeState> _scopes = new();
    private DbConnection? _connection;
    private long _scopeId;
    private int _savepointCounter;

    public XtraqTransactionOrchestrator(IXtraqDbContext dbContext)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
    }

    public bool HasActiveTransaction => _scopes.Count > 0;
    public DbConnection? CurrentConnection => _connection;
    public DbTransaction? CurrentTransaction => _scopes.Count > 0 ? _scopes.Peek().Transaction : null;

    public async ValueTask<XtraqTransactionScope> BeginAsync(XtraqTransactionOptions? options = null, CancellationToken cancellationToken = default)
    {
        options ??= XtraqTransactionOptions.Default;

        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            if (_connection is null)
            {
                _connection = await _dbContext.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
            }

            if (_connection.State != ConnectionState.Open)
            {
                await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
            }

            XtraqTransactionScopeState state;
            if (_scopes.Count == 0)
            {
                var isolation = options.IsolationLevel ?? IsolationLevel.ReadCommitted;
                var transaction = await BeginTransactionAsync(_connection, isolation, cancellationToken).ConfigureAwait(false);
                state = new XtraqTransactionScopeState(++_scopeId, transaction, null, isRoot: true);
            }
            else
            {
                if (options.RequiresNew)
                {
                    throw new NotSupportedException("RequiresNew transactions are not supported yet.");
                }

                var parent = _scopes.Peek();
                var savepoint = GenerateSavepointName();
                parent.Transaction.Save(savepoint);
                state = new XtraqTransactionScopeState(++_scopeId, parent.Transaction, savepoint, isRoot: false);
            }

            _scopes.Push(state);
            return new XtraqTransactionScope(this, state, _connection, state.Transaction);
        }
        finally
        {
            _gate.Release();
        }
    }

    internal async ValueTask CommitAsync(XtraqTransactionScopeState state, CancellationToken cancellationToken)
    {
        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            EnsureCurrentScope(state);

            if (state.Status == XtraqTransactionScopeStatus.Committed)
            {
                return;
            }

            if (state.Status == XtraqTransactionScopeStatus.RolledBack)
            {
                throw new InvalidOperationException("Cannot commit a scope that has already been rolled back.");
            }

            if (state.IsRoot)
            {
                state.Transaction.Commit();
                state.MarkCommitted();
                _scopes.Pop();
                await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                await DisposeConnectionAsync().ConfigureAwait(false);
            }
            else
            {
                state.MarkCommitted();
                _scopes.Pop();
            }
        }
        finally
        {
            _gate.Release();
        }
    }

    internal async ValueTask RollbackAsync(XtraqTransactionScopeState state, CancellationToken cancellationToken)
    {
        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            EnsureCurrentScope(state);

            if (state.Status == XtraqTransactionScopeStatus.RolledBack)
            {
                return;
            }

            if (state.Status == XtraqTransactionScopeStatus.Committed)
            {
                throw new InvalidOperationException("Cannot roll back a scope that has already been committed.");
            }

            if (state.IsRoot)
            {
                state.Transaction.Rollback();
                state.MarkRolledBack();
                _scopes.Pop();
                await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                await DisposeConnectionAsync().ConfigureAwait(false);
            }
            else
            {
                if (state.SavepointName is not null)
                {
                    state.Transaction.Rollback(state.SavepointName);
                }
                else
                {
                    state.Transaction.Rollback();
                }

                state.MarkRolledBack();
                _scopes.Pop();
            }
        }
        finally
        {
            _gate.Release();
        }
    }

    internal ValueTask DisposeScopeAsync(XtraqTransactionScopeState state)
    {
        if (state.Status == XtraqTransactionScopeStatus.Active)
        {
            return RollbackAsync(state, CancellationToken.None);
        }

        return ValueTask.CompletedTask;
    }

    private void EnsureCurrentScope(XtraqTransactionScopeState state)
    {
        if (_scopes.Count == 0 || !ReferenceEquals(_scopes.Peek(), state))
        {
            throw new InvalidOperationException("Transaction scopes must be completed in LIFO order.");
        }
    }

    private string GenerateSavepointName()
    {
        var value = Interlocked.Increment(ref _savepointCounter);
        return FormattableString.Invariant($"xtraq_sp_{value}");
    }

    private static ValueTask<DbTransaction> BeginTransactionAsync(DbConnection connection, IsolationLevel isolationLevel, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return new(connection.BeginTransaction(isolationLevel));
    }

    private static ValueTask DisposeTransactionAsync(DbTransaction transaction)
    {
        if (transaction is IAsyncDisposable asyncDisposable)
        {
            return asyncDisposable.DisposeAsync();
        }

        transaction.Dispose();
        return ValueTask.CompletedTask;
    }

    private async ValueTask DisposeConnectionAsync()
    {
        if (_connection is not null)
        {
            var connection = _connection;
            _connection = null;

            if (connection is IAsyncDisposable asyncDisposable)
            {
                await asyncDisposable.DisposeAsync().ConfigureAwait(false);
            }
            else
            {
                connection.Dispose();
            }
        }
    }
}

public sealed class XtraqTransactionScope : IAsyncDisposable
{
    private readonly XtraqTransactionOrchestrator _owner;
    private readonly XtraqTransactionScopeState _state;
    private int _disposed;

    internal XtraqTransactionScope(
        XtraqTransactionOrchestrator owner,
        XtraqTransactionScopeState state,
        DbConnection connection,
        DbTransaction transaction)
    {
        _owner = owner;
        _state = state;
        Connection = connection;
        Transaction = transaction;
    }

    public DbConnection Connection { get; }
    public DbTransaction Transaction { get; }
    public bool IsRoot => _state.IsRoot;

    public ValueTask CommitAsync(CancellationToken cancellationToken = default)
        => _owner.CommitAsync(_state, cancellationToken);

    public ValueTask RollbackAsync(CancellationToken cancellationToken = default)
        => _owner.RollbackAsync(_state, cancellationToken);

    public async ValueTask DisposeAsync()
    {
        if (Interlocked.Exchange(ref _disposed, 1) != 0)
        {
            return;
        }

        await _owner.DisposeScopeAsync(_state).ConfigureAwait(false);
    }
}

internal enum XtraqTransactionScopeStatus
{
    Active,
    Committed,
    RolledBack
}

internal sealed class XtraqTransactionScopeState
{
    public XtraqTransactionScopeState(long id, DbTransaction transaction, string? savepointName, bool isRoot)
    {
        Id = id;
        Transaction = transaction;
        SavepointName = savepointName;
        IsRoot = isRoot;
        Status = XtraqTransactionScopeStatus.Active;
    }

    public long Id { get; }
    public DbTransaction Transaction { get; }
    public string? SavepointName { get; }
    public bool IsRoot { get; }
    public XtraqTransactionScopeStatus Status { get; private set; }

    public void MarkCommitted() => Status = XtraqTransactionScopeStatus.Committed;
    public void MarkRolledBack() => Status = XtraqTransactionScopeStatus.RolledBack;
}
