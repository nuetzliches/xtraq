---
title: Minimal APIs & DTO Mapping
description: Wire generated Xtraq procedures into ASP.NET Core Minimal APIs and translate the typed results into domain DTOs without leaking SQL-specific details.
---

## Putting Generated Procedures Behind a Minimal API

The project template in `samples/restapi/Program.cs` demonstrates how any generated procedure‚ÄîJSON-enabled or purely tabular‚Äîplugs into a Minimal API endpoint. Resolve the connection string once, register the generated `IXtraqDbContext`, call the typed helper (for example `FileFindAsJsonAsync` or `InvoiceListAsync`), and pass the projection straight to the client or a mapper.

::tabs{.w-full}
:::tabs-item{label="Minimal API (net8.0)"}

    ```csharp
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq; // namespace emitted by xtraq build

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseHttpsRedirection();

    app.MapGet("/files/{fileId:int}", async Task<IResult> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return Results.NotFound(new { error = $"File {fileId} was not found." });
        }

        var dto = FileMappings.ToSummary(row);
        return Results.Ok(dto);
      }
      catch (SqlException ex)
      {
        return Results.Problem("Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: SqlProblemPayload.From(ex));
      }
    });

    app.Run();
    ```

:::
:::tabs-item{label="Minimal API (net10.0)"}

    ```csharp
    using Microsoft.AspNetCore.Http.HttpResults;
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddProblemDetails();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseExceptionHandler();
    app.UseHttpsRedirection();

    var files = app.MapGroup("/files").WithTags("Files");

    files.MapGet("/{fileId:int}", async Task<Results<Ok<FileSummary>, NotFound, ProblemHttpResult>> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return TypedResults.NotFound();
        }

        var dto = FileMappings.ToSummary(row);
        return TypedResults.Ok(dto);
      }
      catch (SqlException ex)
      {
        var problem = SqlProblemPayload.From(ex);
        return TypedResults.Problem(title: "Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: problem);
      }
    });

    app.Run();
    ```

:::
::

> The procedure used in the snippet returns JSON, but the pattern is identical for tabular result sets. Swap in the generated helper that matches your stored procedure.

## Streaming Result Sets Without Buffering

Generated procedures expose paired `StreamResult‚Ä¶Async` helpers when a result set supports forward-only streaming. These helpers execute the stored procedure, position the reader on the selected result set, and push each row into a user-supplied callback without materialising the aggregate payload.

```csharp
app.MapGet("/users/stream", async Task StreamUsers(HttpResponse response, IXtraqDbContext db, CancellationToken ct) =>
{
  response.StatusCode = StatusCodes.Status200OK;
  response.ContentType = "application/x-ndjson"; // newline-delimited JSON
  response.Headers.CacheControl = "no-store";

  await using var writer = new StreamWriter(response.Body, leaveOpen: true);
  var jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);

  await db.UserList.StreamResultResultSet1Async(
    new UserListInput(includeInactive: false),
    async (row, token) =>
    {
      var payload = JsonSerializer.Serialize(row, jsonOptions);
      await writer.WriteLineAsync(payload.AsMemory(), token).ConfigureAwait(false);
      await writer.FlushAsync(token).ConfigureAwait(false);
    },
    ct).ConfigureAwait(false);
});
```

Key points:

- The generator keeps the callback signature as `Func<TRow, CancellationToken, ValueTask>` so async pipelines (writing to HTTP, channels, gRPC streams) remain allocation-friendly.
- Output parameters, when present, are returned by the streaming helper. Capture them via `var output = await db.Proc.StreamResult‚Ä¶Async(...)` before writing the HTTP response headers.
- You can combine streaming with Domain DTOs by projecting inside the callback or forwarding rows into a dedicated mapper class.

## Example: Rehydrating Results into a Domain DTO

Endpoints stay orchestration-focused when DTO mapping and enrichment live beside the generated extensions. The mapper below translates the generated record (`FileFindAsJsonResultSet1Result`) into a domain-level summary and, on demand, streams file content into a Base64 payload‚Äîillustrating the same technique you would use for non-JSON result sets.

```csharp
internal static class FileMappings
{
  public static FileSummary ToSummary(FileFindAsJsonResultSet1Result row) => new(
    row.fileId,
    row.fileName,
    Normalize(row.contentType),
    row.size,
    Normalize(row.hash));

  public static async Task<FileSummary> WithContentAsync(this FileSummary summary, string contentPath, CancellationToken ct)
  {
    var bytes = await File.ReadAllBytesAsync(contentPath, ct).ConfigureAwait(false);
    return summary with { Base64Content = Convert.ToBase64String(bytes) };
  }

  private static string? Normalize(string? value) => string.IsNullOrWhiteSpace(value) ? null : value;
}

internal sealed record FileSummary(int FileId, string FileName, string? ContentType, long Size, string? Hash)
{
  public string? Base64Content { get; init; }
}

internal static class SqlProblemPayload
{
  public static IDictionary<string, object?> From(SqlException exception) =>
    new Dictionary<string, object?>
    {
      ["sqlNumber"] = exception.Number,
      ["sqlState"] = exception.State,
      ["server"] = exception.Server,
      ["procedure"] = exception.Procedure,
      ["lineNumber"] = exception.LineNumber
    };
}
```

## Evaluating Builder-style Extensions for Generated Procedures

Some teams prefer a fluent surface when composing procedure executions‚Äîselecting only the result set they need, decorating the projection, or flowing the data straight into a minimal API group. The generated code purposefully stays minimal so callers can layer these behaviours without modifying the artifacts. A thin builder around the generated extensions keeps that separation intact.

### Recommended Pattern

1. **Keep the generated partial untouched.** Add a sibling partial class or extension in your application project.
2. **Expose fluent building blocks** that re-use the strongly typed result records.
3. **Defer materialisation** until `ExecuteAsync` to avoid buffering when streaming suffices.

```csharp
public sealed class ProcedureCallBuilder<TInput>(IXtraqDbContext db, TInput input)
{
  private Func<TInput, CancellationToken, Task<object?>> _executor = static (_, _) => Task.FromResult<object?>(null);
  private Func<object?, object?> _projector = static result => result;

  public ProcedureCallBuilder<TInput> WithExecutor(Func<TInput, CancellationToken, Task<object?>> executor)
  {
    ArgumentNullException.ThrowIfNull(executor);
    _executor = executor;
    return this;
  }

  public ProcedureCallBuilder<TInput> Project(Func<object?, object?> projector)
  {
    ArgumentNullException.ThrowIfNull(projector);
    _projector = projector;
    return this;
  }

  public async Task<TResult> ExecuteAsync<TResult>(CancellationToken ct = default)
  {
    var raw = await _executor(input, ct).ConfigureAwait(false);
    return (TResult)_projector(raw)!;
  }
}

public static class UserBuilderExtensions
{
  public static ProcedureCallBuilder<UserFindInput> SelectPreferredContacts(this IXtraqDbContext db, UserFindInput input)
    => new(db, input)
      .WithExecutor(async (payload, ct) => await db.UserFindAsync(payload, ct).ConfigureAwait(false))
      .Project(result =>
      {
        if (result is not UserFindResult response)
        {
          return Array.Empty<UserFindResultSet1Result>();
        }

        return response.Result
          .Where(r => string.Equals(r.PreferredLocale, "en-US", StringComparison.OrdinalIgnoreCase))
          .ToArray();
      });
}

// Minimal API usage
db.SelectPreferredContacts(new UserFindInput(userId))
  .ExecuteAsync<UserFindResultSet1Result[]>(ct);
```

### Findings

- ‚úÖ **Feasible without template changes.** Builders can live in application code, wrap generated `IXtraqDbContext` extensions, and remain testable.
- ‚ö†Ô∏è **Avoid hiding streaming APIs.** If a procedure exposes a `StreamResult‚Ä¶Async` helper, keep builder overloads that delegate to the streaming pipeline; buffering everything defeats the generator‚Äôs opt-in streaming story.
- üîÑ **Consider DI scoping.** Builders should stay cheap to allocate and respect the existing `IXtraqDbContext` lifetime to avoid connection leaks.
- üìÑ **Document intent.** Add XML comments on custom builders so team members know they sit _outside_ the generator and are safe to evolve.

If you need more prescriptive control (for example multiple chained transforms), place the builder inside your application layer and keep partials for smaller tweaks. This preserves deterministic code generation while unlocking fluent composition where it belongs.

Guidelines when exposing generated procedures via HTTP endpoints:

- Always read from the typed projection (`Result`, `ResultSets`, or strongly typed record) and reserve raw JSON helpers for diagnostics.
- Keep endpoints orchestration-focused. Mapping and enrichment belong in dedicated helpers like `FileMappings` or partial classes layered over the generated code.
- Compute expensive enrichments (for example file IO) via helpers such as `WithContentAsync` that accept the resolved storage path instead of embedding file-system logic inside the endpoint.
- Prefer records and `with` expressions to extend immutable summaries instead of mutating generated types.
- Normalise nullable strings early so downstream formatters do not emit empty values that could break clients.
- Promote consistent problem responses‚Äîwrapping `SqlException` into RFC 7807 payloads keeps infrastructure failures observable without leaking raw SQL errors.

These practices keep API controllers thin, preserve deterministic generator output, and make downstream contracts explicit‚Äîregardless of whether the procedure emits JSON payloads or tabular result sets.
