{{ HEADER }}
#nullable enable
namespace {{ Namespace }};

{{ UsingDirectives }}

/// <summary>
/// Represents the contract for the stored procedure <c>{{ Schema }}.{{ Name }}</c> including parameters, result sets and execution metadata.
/// </summary>
/// <remarks>
/// Generated by the Xtraq CLI. To change this artifact, modify the underlying SQL stored procedure definition.
/// </remarks>
{{#if HasInput}}
public readonly record struct {{ InputTypeName }}(
{{#each InputParameters as parameter}}    {{ parameter.ClrType }} {{ parameter.PropertyName }}{{ parameter.Comma }}
{{/each}});

{{/if}}
{{#if HasOutput}}
/// <summary>
/// Captures OUTPUT parameter values returned by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
public readonly record struct {{ OutputTypeName }}(
{{#each OutputFields as field}}    {{ field.ClrType }} {{ field.PropertyName }}{{ field.Comma }}
{{/each}});

{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
/// <summary>
/// Represents the result set <c>{{ resultSet.Name }}</c> emitted by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
{{ resultSet.NestedRecordsBlock }}public readonly record struct {{ resultSet.TypeName }}(
{{ resultSet.FieldsBlock }}
);

{{/each}}
{{/if}}
public sealed class {{ UnifiedResultTypeName }}
{
	/// <summary>
	/// Indicates whether the procedure executed without raising an error.
	/// </summary>
	public bool Success { get; init; }
	/// <summary>
	/// Contains the error message when <see cref="Success"/> is <c>false</c>; otherwise <c>null</c>.
	/// </summary>
	public string? Error { get; init; }
{{#if HasOutput}}
	/// <summary>
	/// OUTPUT parameter payload returned by the procedure.
	/// </summary>
	public {{ OutputTypeName }}? Output { get; init; }
{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
	/// <summary>
	/// Result set <c>{{ resultSet.Name }}</c> projected as a strongly typed sequence.
	/// </summary>
	public {{ resultSet.PropType }} {{ resultSet.PropName }} { get; init; } = {{ resultSet.PropDefault }};
{{#if resultSet.HasRaw}}
	/// <summary>
	/// Raw JSON payload captured for result set <c>{{ resultSet.Name }}</c>.
	/// </summary>
	public string? {{ resultSet.RawPropName }} { get; init; } = {{ resultSet.RawPropDefault }};
{{/if}}
{{/each}}
{{/if}}
}

internal static partial class {{ PlanTypeName }}
{
	private static ProcedureExecutionPlan? _cached;
	public static ProcedureExecutionPlan Instance => _cached ??= Create();
	private static ProcedureExecutionPlan Create()
	{
{{#if HasParameters}}
		var parameters = new ProcedureParameter[]
		{
{{#each ParameterLines as parameterLine}}            {{ parameterLine }},
{{/each}}        };
{{else}}
		var parameters = Array.Empty<ProcedureParameter>();
{{/if}}

{{#if HasResultSets}}
		var resultSets = new ResultSetMapping[]
		{
{{#each ResultSets as resultSet}}            new("{{ resultSet.Name }}", async (r, ct) =>
			{
{{ resultSet.BodyBlock }}
			}),

{{/each}}        };
{{else}}
		var resultSets = Array.Empty<ResultSetMapping>();
{{/if}}

		object? OutputFactory(IReadOnlyDictionary<string, object?> values) => {{#if HasOutput}}new {{ OutputTypeName }}({{ OutputFactoryArgs }}){{else}}null{{/if}};
		object AggregateFactory(bool success, string? error, object? output, IReadOnlyDictionary<string, object?> outputs, object[] rs)
		{
			return new {{ UnifiedResultTypeName }}
			{
				Success = success,
				Error = error{{#if HasOutput}},
				Output = ({{ OutputTypeName }}?)output{{/if}}{{#if HasResultSets}}{{#each ResultSets as resultSet}},
				// ResultSet {{ resultSet.Index }} -> {{ resultSet.PropName }}
				{{ resultSet.PropName }} = {{ resultSet.AggregateAssignment }}{{#if resultSet.HasRaw}},
				{{ resultSet.RawPropName }} = {{ resultSet.RawAggregateAssignment }}{{/if}}{{/each}}{{/if}}
			};
		}
		void Binder(DbCommand cmd, object? state)
		{
{{#if HasInput}}
			var input = ({{ InputTypeName }})state!;
{{#each InputAssignments as assignment}}
			{{ assignment }}
{{/each}}
{{/if}}
		}
		return new ProcedureExecutionPlan(
			"{{ ProcedureFullName }}", parameters, resultSets, OutputFactory, AggregateFactory, Binder);
	}
}

/// <summary>Convenience extension for executing '{{ ProcedureFullName }}' via an <see cref="IXtraqDbContext"/>.</summary>
public static class {{ ProcedureTypeName }}Extensions
{
	public static async Task<{{ UnifiedResultTypeName }}> {{ ProcedureTypeName }}Async(this IXtraqDbContext db{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		await using var conn = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		return await {{ ProcedureTypeName }}Procedure.ExecuteAsync(conn{{#if HasInput}}, input{{/if}}, cancellationToken).ConfigureAwait(false);
	}

{{#each ResultSets as resultSet}}{{#if resultSet.SupportsStreaming}}
	/// <summary>Streams result set <c>{{ resultSet.Name }}</c> without buffering it into the aggregate payload.</summary>
	public static async Task{{#if ../../HasOutput}}<{{ ../../OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(this IXtraqDbContext db{{#if ../../HasInput}}, {{ ../../InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, CancellationToken, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(db);
		ArgumentNullException.ThrowIfNull(onRowAsync);
		await using var connection = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		{{#if ../../HasOutput}}var output = {{/if}}await {{ ../../ProcedureTypeName }}Procedure.{{ resultSet.StreamMethodName }}(connection{{#if ../../HasInput}}, input{{/if}}, onRowAsync, cancellationToken).ConfigureAwait(false);
		{{#if ../../HasOutput}}return output;{{/if}}
	}

	public static Task{{#if ../../HasOutput}}<{{ ../../OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(this IXtraqDbContext db{{#if ../../HasInput}}, {{ ../../InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(onRowAsync);
		return {{ resultSet.StreamMethodName }}(db{{#if ../../HasInput}}, input{{/if}}, (row, ct) => onRowAsync(row), cancellationToken);
	}

{{/if}}{{/each}}
}

/// <summary>Low-level execution wrapper for a single stored procedure invocation.</summary>
public static class {{ ProcedureTypeName }}Procedure
{
	public const string Name = "{{ ProcedureFullName }}";
	public static Task<{{ UnifiedResultTypeName }}> ExecuteAsync(DbConnection connection{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		return ProcedureExecutor.ExecuteAsync<{{ UnifiedResultTypeName }}>(connection, {{ PlanTypeName }}.Instance, {{#if HasInput}}input{{else}}null{{/if}}, cancellationToken);
	}

{{#each ResultSets as resultSet}}{{#if resultSet.SupportsStreaming}}
	/// <summary>Streams result set <c>{{ resultSet.Name }}</c> using the supplied row callback.</summary>
	public static async Task{{#if ../../HasOutput}}<{{ ../../OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(DbConnection connection{{#if ../../HasInput}}, {{ ../../InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, CancellationToken, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(connection);
		ArgumentNullException.ThrowIfNull(onRowAsync);

		async Task StreamCoreAsync(DbDataReader reader, CancellationToken ct)
		{
{{#if resultSet.HasStreamOrdinals}}{{ resultSet.StreamOrdinalDecls }}
{{/if}}			while (await reader.ReadAsync(ct).ConfigureAwait(false))
			{
				var row = {{#if resultSet.HasFieldExpressions}}new {{ resultSet.TypeName }}({{ resultSet.StreamFieldExprs }}){{else}}new {{ resultSet.TypeName }}(){{/if}};
				await onRowAsync(row, ct).ConfigureAwait(false);
			}
		}

{{#if ../../HasOutput}}		var output = await ProcedureExecutor.StreamResultSetAsync(connection, {{ ../../PlanTypeName }}.Instance, {{ resultSet.StreamIndex }}, StreamCoreAsync, {{#if ../../HasInput}}input{{else}}null{{/if}}, cancellationToken).ConfigureAwait(false);
		return ({{ ../../OutputTypeName }}?)output;
{{else}}		await ProcedureExecutor.StreamResultSetAsync(connection, {{ ../../PlanTypeName }}.Instance, {{ resultSet.StreamIndex }}, StreamCoreAsync, {{#if ../../HasInput}}input{{else}}null{{/if}}, cancellationToken).ConfigureAwait(false);
{{/if}}	}

	public static Task{{#if ../../HasOutput}}<{{ ../../OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(DbConnection connection{{#if ../../HasInput}}, {{ ../../InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(onRowAsync);
		return {{ resultSet.StreamMethodName }}(connection{{#if ../../HasInput}}, input{{/if}}, (row, ct) => onRowAsync(row), cancellationToken);
	}

{{/if}}{{/each}}
}
