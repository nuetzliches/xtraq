---
title: Minimal APIs & DTO Mapping
description: Wire generated Xtraq procedures into ASP.NET Core Minimal APIs and translate the typed results into domain DTOs without leaking SQL-specific details.
---

## Putting Generated Procedures Behind a Minimal API

The project template in `samples/restapi/Program.cs` demonstrates how any generated procedure—JSON-enabled or purely tabular—plugs into a Minimal API endpoint. Resolve the connection string once, register the generated `IXtraqDbContext`, call the typed helper (for example `FileFindAsJsonAsync` or `InvoiceListAsync`), and pass the projection straight to the client or a mapper.

::tabs{.w-full}
:::tabs-item{label="Minimal API (net8.0)"}

    ```csharp
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq; // namespace emitted by xtraq build

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseHttpsRedirection();

    app.MapGet("/files/{fileId:int}", async Task<IResult> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return Results.NotFound(new { error = $"File {fileId} was not found." });
        }

        var dto = FileMappings.ToSummary(row);
        return Results.Ok(dto);
      }
      catch (SqlException ex)
      {
        return Results.Problem("Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: SqlProblemPayload.From(ex));
      }
    });

    app.Run();
    ```

:::
:::tabs-item{label="Minimal API (net10.0)"}

    ```csharp
    using Microsoft.AspNetCore.Http.HttpResults;
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddProblemDetails();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseExceptionHandler();
    app.UseHttpsRedirection();

    var files = app.MapGroup("/files").WithTags("Files");

    files.MapGet("/{fileId:int}", async Task<Results<Ok<FileSummary>, NotFound, ProblemHttpResult>> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return TypedResults.NotFound();
        }

        var dto = FileMappings.ToSummary(row);
        return TypedResults.Ok(dto);
      }
      catch (SqlException ex)
      {
        var problem = SqlProblemPayload.From(ex);
        return TypedResults.Problem(title: "Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: problem);
      }
    });

    app.Run();
    ```

:::
::

> The procedure used in the snippet returns JSON, but the pattern is identical for tabular result sets. Swap in the generated helper that matches your stored procedure.

> Want to reuse an existing Entity Framework Core transaction? See [Entity Framework Integration](./6.entity-framework-integration.md) for the ambient bridge and registration steps.

## Streaming Result Sets Without Buffering

Generated procedures expose paired `StreamResult…Async` helpers when a result set supports forward-only streaming. These helpers execute the stored procedure, position the reader on the selected result set, and push each row into a user-supplied callback without materialising the aggregate payload.

```csharp
app.MapGet("/users/stream", async Task StreamUsers(HttpResponse response, IXtraqDbContext db, CancellationToken ct) =>
{
  response.StatusCode = StatusCodes.Status200OK;
  response.ContentType = "application/x-ndjson"; // newline-delimited JSON
  response.Headers.CacheControl = "no-store";

  await using var writer = new StreamWriter(response.Body, leaveOpen: true);
  var jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);

  await db.UserList.StreamResultResultSet1Async(
    new UserListInput(includeInactive: false),
    async (row, token) =>
    {
      var payload = JsonSerializer.Serialize(row, jsonOptions);
      await writer.WriteLineAsync(payload.AsMemory(), token).ConfigureAwait(false);
      await writer.FlushAsync(token).ConfigureAwait(false);
    },
    ct).ConfigureAwait(false);
});
```

Key points:

- The generator keeps the callback signature as `Func<TRow, CancellationToken, ValueTask>` so async pipelines (writing to HTTP, channels, gRPC streams) remain allocation-friendly.
- Output parameters, when present, are returned by the streaming helper. Capture them via `var output = await db.Proc.StreamResult…Async(...)` before writing the HTTP response headers.
- You can combine streaming with Domain DTOs by projecting inside the callback or forwarding rows into a dedicated mapper class.

## Example: Rehydrating Results into a Domain DTO

Endpoints stay orchestration-focused when DTO mapping and enrichment live beside the generated extensions. The mapper below translates the generated record (`FileFindAsJsonResultSet1Result`) into a domain-level summary and, on demand, streams file content into a Base64 payload—illustrating the same technique you would use for non-JSON result sets.

```csharp
internal static class FileMappings
{
  public static FileSummary ToSummary(FileFindAsJsonResultSet1Result row) => new(
    row.fileId,
    row.fileName,
    Normalize(row.contentType),
    row.size,
    Normalize(row.hash));

  public static async Task<FileSummary> WithContentAsync(this FileSummary summary, string contentPath, CancellationToken ct)
  {
    var bytes = await File.ReadAllBytesAsync(contentPath, ct).ConfigureAwait(false);
    return summary with { Base64Content = Convert.ToBase64String(bytes) };
  }

  private static string? Normalize(string? value) => string.IsNullOrWhiteSpace(value) ? null : value;
}

internal sealed record FileSummary(int FileId, string FileName, string? ContentType, long Size, string? Hash)
{
  public string? Base64Content { get; init; }
}

internal static class SqlProblemPayload
{
  public static IDictionary<string, object?> From(SqlException exception) =>
    new Dictionary<string, object?>
    {
      ["sqlNumber"] = exception.Number,
      ["sqlState"] = exception.State,
      ["server"] = exception.Server,
      ["procedure"] = exception.Procedure,
      ["lineNumber"] = exception.LineNumber
    };
}
```

db.SelectPreferredContacts(new UserFindInput(userId))

## Fluent Procedure Pipeline

Generated projects ship an opt-in helper (`ProcedurePipelineExtensions`) that layers configuration primitives over the typed `IXtraqDbContext` surface without touching the artefacts themselves. The workflow splits into two stages:

- `ConfigureProcedure` / `WithExecutor` build a `ProcedureCallPipeline` that can be labelled, decorated with `IProcedureExecutionPolicy` instances, and then materialised via `ProcedureCallExecution` for `Select`, `SelectAsync`, `Tap`, and `TapAsync` composition.
- `ConfigureProcedureStream` / `WithExecutor` produce a `ProcedureStreamExecution` that reuses the same policy pipeline while adding streaming helpers (`ForEach`, `TapCompletion`, `BufferAsync`, `AggregateAsync`).

```csharp
var execution = db.ConfigureProcedure(new UserFindInput(userId))
  .WithLabel("users.find")
  .WithPolicies(new IProcedureExecutionPolicy[] { new SampleRetryPolicy(), new SampleCircuitBreakerPolicy() })
  .WithExecutor(static (ctx, input, ct) => ctx.UserFindAsync(input, ct));

var favouriteContacts = await execution
  .Select(result => result.Result
    .Where(r => string.Equals(r.PreferredLocale, "en-US", StringComparison.OrdinalIgnoreCase))
    .ToArray())
  .ExecuteAsync(ct);

var streamed = await db.ConfigureProcedureStream<UserListInput, UserListResultSet1Row>(
    new UserListInput(includeInactive: false))
  .WithLabel("users.stream")
  .WithPolicy(new SampleRetryPolicy())
  .WithExecutor(static (ctx, input, onRow, ct) => ctx.UserList.StreamResultResultSet1Async(input, onRow, ct))
  .AggregateAsync((rows, output) => new
  {
    Count = rows.Count,
    Output = output
  },
  ct);
```

### Pipeline Guidelines

1. **Keep generated partials untouched.** Pipelines live beside the artefacts and never edit the generated classes.
2. **Flow DI across boundaries.** Instantiate the pipeline within the scope that owns `IXtraqDbContext` so the connection lifetime mirrors existing patterns.
3. **Lean on policies.** Implement retry, timeout, and telemetry concerns via `IProcedureExecutionPolicy` instead of layering ad-hoc delegates inside the execution chain.
4. **Prefer streaming when available.** `ProcedureStreamExecution` composes row handlers, exposes completion taps, and offers `BufferAsync`/`AggregateAsync` helpers for when materialisation is unavoidable.
5. **Document intent.** Wrap pipeline-based workflows in extension methods with XML summaries so downstream teams know the fluent surface is opt-in.

The helper keeps the generator deterministic while unlocking richer composition for teams that prefer fluent orchestration, centralised instrumentation, or middleware-friendly streaming without redundant buffering.

Guidelines when exposing generated procedures via HTTP endpoints:

- Always read from the typed projection (`Result`, `ResultSets`, or strongly typed record) and reserve raw JSON helpers for diagnostics.
- Keep endpoints orchestration-focused. Mapping and enrichment belong in dedicated helpers like `FileMappings` or partial classes layered over the generated code.
- Compute expensive enrichments (for example file IO) via helpers such as `WithContentAsync` that accept the resolved storage path instead of embedding file-system logic inside the endpoint.
- Prefer records and `with` expressions to extend immutable summaries instead of mutating generated types.
- Normalise nullable strings early so downstream formatters do not emit empty values that could break clients.
- Promote consistent problem responses—wrapping `SqlException` into RFC 7807 payloads keeps infrastructure failures observable without leaking raw SQL errors.

These practices keep API controllers thin, preserve deterministic generator output, and make downstream contracts explicit—regardless of whether the procedure emits JSON payloads or tabular result sets.
