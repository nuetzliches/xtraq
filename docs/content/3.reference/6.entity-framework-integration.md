---
title: Entity Framework Integration
description: Bridge the Xtraq transaction orchestrator with existing Entity Framework Core DbContext scopes.
---

## Overview

Xtraq exposes a scoped transaction orchestrator that keeps a shared connection per request, supports nested savepoints, and can spawn `RequiresNew` scopes on demand. When an application already uses Entity Framework Core, you can let generated procedures participate in the same ambient transaction by implementing `IXtraqAmbientTransactionAccessor` on the `IXtraqDbContext` surface exposed to Xtraq.

## Implementing the Ambient Accessor

```csharp
public sealed class EfAmbientXtraqContext : IXtraqDbContext, IXtraqAmbientTransactionAccessor
{
  private readonly DbContext _efContext;

  public EfAmbientXtraqContext(DbContext efContext)
  {
    _efContext = efContext;
  }

  public DbTransaction? AmbientTransaction => _efContext.Database.CurrentTransaction?.GetDbTransaction();
  public DbConnection? AmbientConnection => _efContext.Database.GetDbConnection();

  public async Task<DbConnection> OpenConnectionAsync(CancellationToken cancellationToken = default)
  {
    var connection = _efContext.Database.GetDbConnection();
    if (connection.State != ConnectionState.Open)
    {
      await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
    }

    return connection;
  }

  public DbConnection OpenConnection()
  {
    var connection = _efContext.Database.GetDbConnection();
    if (connection.State != ConnectionState.Open)
    {
      connection.Open();
    }

    return connection;
  }

  public Task<bool> HealthCheckAsync(CancellationToken cancellationToken = default)
    => Task.FromResult(true);

  public int CommandTimeout => _efContext.Database.GetCommandTimeout() ?? 30;
}
```

The accessor exposes the connection and transaction managed by EF so the orchestrator can reuse them for generated procedures without double-committing or disposing resources it does not own.

## Registering the Bridge

Resolve both DbContexts from the same DI scope so they share lifetimes:

```csharp
builder.Services.AddDbContext<AppDbContext>(options =>
{
  options.UseSqlServer(connectionString);
});

builder.Services.AddXtraqDbContext(options =>
{
  options.ConnectionString = connectionString;
});

builder.Services.AddScoped<IXtraqDbContext>(sp =>
{
  var efContext = sp.GetRequiredService<AppDbContext>();
  return new EfAmbientXtraqContext(efContext);
});
```

## Usage Guidelines

- Resolve the EF `DbContext` and the generated `IXtraqDbContext` inside the same request scope.
- Call `BeginAsync` only when you need an explicit scope; otherwise generated procedures automatically join the ambient EF transaction.
- Use `RequiresNew` for cross-cutting work that must run outside the ambient transaction (for example audit trails or idempotency checkpoints).
- Allow EF Core to manage the lifetime of the shared connection and transaction; the orchestrator detects externally owned resources and skips disposal.
- When EF does not expose a current transaction, the orchestrator will create its own connection and transaction as usual.

## Additional Resources

- [Transaction API roadmap entry](../5.roadmap/index.md#transaction-api)
- [Migration playbook](../1.getting-started/4.migrating-from-spocr.md)
