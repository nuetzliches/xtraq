---
title: Table Types (UDTT) Generation
description: xtraq generates strongly-typed records for each user-defined table type (UDTT) discovered in the snapshot. This enables safe passing of structured values (lists / sets) to stored procedures without manual DataTable plumbing.
---

## Goals

- Preserve original UDTT names (only minimal sanitizing)
- Deterministic hashing (timestamp line ignored during diff/hash)
- Single shared interface `ITableType` for all generated table types
- Per-schema folder layout under `xtraq/<SchemaPascalCase>/`

## Naming & Preservation

- Original snapshot name is retained exactly (case preserved) except for sanitizing invalid C# identifier characters.
- No forced `*TableType` suffix is added.
- Hyphenated schema names are normalized to PascalCase at folder level (e.g. `user-admin` schema -> `UserAdmin`).

## Timestamp Handling

Each generated file may include a `<remarks>` line with a generation timestamp. This line is ignored by the hash manifest logic so repeated deterministic generation produces identical effective hashes.

## Interface & Structure

```csharp
public interface ITableType {}

// Example generated record (simplified)
public sealed record UserContactTableType(
    int UserId,
    string Email,
    string Phone
) : ITableType;
```

Records are emitted as `sealed record` types for value semantics and deconstruction support.

## Usage Example

```csharp
var contacts = new List<UserContactTableType>
{
    new(1, "alice@example.com", "+1-555-0100"),
    new(2, "bob@example.com", "+1-555-0101")
};

await context.CreateUserBatchAsync(new CreateUserBatchInput { Contacts = contacts });
```

Internally the executor binds UDTT parameters using a structured parameter binder (ADO.NET `SqlParameter` with `SqlDbType.Structured`).

## Allow-List Filtering

When `XTRAQ_BUILD_SCHEMAS` is set (either in `.env` or via `.xtraqconfig`), the build pipeline now walks procedure → UDTT dependencies collected during snapshotting. Only table types referenced by allow-listed procedures are emitted. Cross-schema references are preserved automatically: if `sample.SyncUserContacts` consumes `shared.AuditLogEntryTableType`, the `shared` artifact is still generated even though the allow-list only names `sample`. Catalog-qualified references (`catalog.schema.type`) remain intact, so multi-database UDTTs continue to bind correctly.

If the allow-list is empty, the generator emits every discovered UDTT. This matches the behaviour of the procedure generator.

## Customising UDTT Binding

Generated binders convert UDTT inputs into `SqlParameter` instances with `SqlDbType.Structured` and pipe the payload through `TvpHelper.BuildRecords`. Some scenarios (cross-database execution, custom precision/length metadata, diagnostics) require tweaking those parameters before they hit the server. Two hook points are available without editing generated files:

- **Global interceptor:** Implement `Xtraq.Execution.IXtraqProcedureInterceptor` and register it once via `ProcedureExecutor.SetInterceptor`. The interceptor runs after the generated binder but before `ExecuteReaderAsync`, so you can set `SqlParameter.TypeName`, tweak `SqlDbType`, or attach logging. Example:

  ```csharp
  using System.Data.Common;
  using Microsoft.Data.SqlClient;
  using Xtraq.Execution;

  public sealed class UdttBinderInterceptor : IXtraqProcedureInterceptor
  {
      private static readonly Dictionary<string, string> TypeNames = new(StringComparer.OrdinalIgnoreCase)
      {
          { "@Contacts", "sample.UserContactTableType" },
          { "@Entries", "shared.AuditLogEntryTableType" }
      };

      public Task<object?> OnBeforeExecuteAsync(string procedureName, DbCommand command, object? state, CancellationToken cancellationToken)
      {
          foreach (DbParameter parameter in command.Parameters)
          {
              if (parameter is SqlParameter sql && sql.SqlDbType == SqlDbType.Structured
                  && string.IsNullOrWhiteSpace(sql.TypeName)
                  && TypeNames.TryGetValue(sql.ParameterName, out var typeName))
              {
                  sql.TypeName = typeName;
              }
          }

          return Task.FromResult<object?>(null);
      }

      public Task OnAfterExecuteAsync(string procedureName, DbCommand command, bool success, string? error, TimeSpan duration, object? beforeState, object? aggregate, CancellationToken cancellationToken)
          => Task.CompletedTask;
  }

  // Called during application start-up
  ProcedureExecutor.SetInterceptor(new UdttBinderInterceptor());
  ```

  The `state` argument passed into `OnBeforeExecuteAsync` is the input record the caller supplied, so per-procedure logic can inspect payloads if needed.

- **Context-level wiring:** Projects that expose a generated `XtraqDbContext` can register the interceptor from a partial class constructor or an IoC module. This keeps binder customisation local to the application layer and avoids modifying generated artifacts.

Use these hooks sparingly—most projects should not need bespoke UDTT binders once the generator knows the type name and column metadata from the snapshot. They are intended for edge cases such as cross-database UDTT execution, custom `SqlMetaData` semantics, or vendor-specific diagnostics.

## Hash & Determinism

Hash manifests filter out the `<remarks>` timestamp line and any benign whitespace differences, ensuring stable hashes across repeated generation runs given unchanged inputs.

Roadmap tracking for table type generation now lives in the central checklist ([Roadmap](../roadmap/index.md)).

## FAQ

**Why not classes?** Records provide concise syntax and built-in equality useful for test assertions.

**Can I extend a generated table type?** Use partial records or composition in domain layer; generated files may be overwritten so avoid direct edits.

**Will names ever be auto-suffixed?** No; stability of original names is prioritized, changes would constitute a breaking change and would ship with dedicated guidance.

---

Status: Draft – will be updated as Allow-List tests and binder docs are added.
