{{ HEADER }}
#nullable enable
namespace {{ Namespace }};

{{ UsingDirectives }}
#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
#endif

/// <summary>
/// Represents the contract for the stored procedure <c>{{ Schema }}.{{ Name }}</c> including parameters, result sets and execution metadata.
/// </summary>
/// <remarks>
/// Generated by the Xtraq CLI. To change this artifact, modify the underlying SQL stored procedure definition.
/// </remarks>
{{#if HasInput}}
public readonly record struct {{ InputTypeName }}(
{{#each InputParameters as parameter}}    {{ parameter.ClrType }} {{ parameter.PropertyName }}{{ parameter.Comma }}
{{/each}});

{{/if}}
{{#if HasOutput}}
/// <summary>
/// Captures OUTPUT parameter values returned by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
public readonly record struct {{ OutputTypeName }}(
{{#each OutputFields as field}}    {{ field.ClrType }} {{ field.PropertyName }}{{ field.Comma }}
{{/each}});

{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
/// <summary>
/// Represents the result set <c>{{ resultSet.Name }}</c> emitted by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
{{ resultSet.NestedRecordsBlock }}public readonly record struct {{ resultSet.TypeName }}(
{{ resultSet.FieldsBlock }}
);

{{/each}}
{{/if}}
public sealed class {{ UnifiedResultTypeName }}
{
	/// <summary>
	/// Indicates whether the procedure executed without raising an error.
	/// </summary>
	public bool Success { get; init; }
	/// <summary>
	/// Contains the error message when <see cref="Success"/> is <c>false</c>; otherwise <c>null</c>.
	/// </summary>
	public string? Error { get; init; }
{{#if HasOutput}}
	/// <summary>
	/// OUTPUT parameter payload returned by the procedure.
	/// </summary>
	public {{ OutputTypeName }}? Output { get; init; }
{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
	/// <summary>
	/// Result set <c>{{ resultSet.Name }}</c> projected as a strongly typed sequence.
	/// </summary>
	public {{ resultSet.PropType }} {{ resultSet.PropName }} { get; init; } = {{ resultSet.PropDefault }};
{{#if resultSet.HasRaw}}
	/// <summary>
	/// Raw JSON payload captured for result set <c>{{ resultSet.Name }}</c>.
	/// </summary>
	public string? {{ resultSet.RawPropName }} { get; init; } = {{ resultSet.RawPropDefault }};
{{/if}}
{{/each}}
{{/if}}
}

internal static partial class {{ PlanTypeName }}
{
	private static ProcedureExecutionPlan? _cached;
	public static ProcedureExecutionPlan Instance => _cached ??= Create();
	private static ProcedureExecutionPlan Create()
	{
{{#if HasParameters}}
		var parameters = new ProcedureParameter[]
		{
{{#each ParameterLines as parameterLine}}            {{ parameterLine }},
{{/each}}        };
{{else}}
		var parameters = Array.Empty<ProcedureParameter>();
{{/if}}

{{#if HasResultSets}}
		var resultSets = new ResultSetMapping[]
		{
{{#each ResultSets as resultSet}}            new("{{ resultSet.Name }}", async (r, ct) =>
			{
{{ resultSet.BodyBlock }}
			}),

{{/each}}        };
{{else}}
		var resultSets = Array.Empty<ResultSetMapping>();
{{/if}}

		object? OutputFactory(IReadOnlyDictionary<string, object?> values) => {{#if HasOutput}}new {{ OutputTypeName }}({{ OutputFactoryArgs }}){{else}}null{{/if}};
		object AggregateFactory(bool success, string? error, object? output, IReadOnlyDictionary<string, object?> outputs, object[] rs)
		{
			return new {{ UnifiedResultTypeName }}
			{
				Success = success,
				Error = error{{#if HasOutput}},
				Output = ({{ OutputTypeName }}?)output{{/if}}{{#if HasResultSets}}{{#each ResultSets as resultSet}},
				// ResultSet {{ resultSet.Index }} -> {{ resultSet.PropName }}
				{{ resultSet.PropName }} = {{ resultSet.AggregateAssignment }}{{#if resultSet.HasRaw}},
				{{ resultSet.RawPropName }} = {{ resultSet.RawAggregateAssignment }}{{/if}}{{/each}}{{/if}}
			};
		}
		void Binder(DbCommand cmd, object? state)
		{
{{#if HasInput}}
			var input = ({{ InputTypeName }})state!;
{{#each InputAssignments as assignment}}
			{{ assignment }}
{{/each}}
{{/if}}
		}
		return new ProcedureExecutionPlan(
			"{{ ProcedureFullName }}", parameters, resultSets, OutputFactory, AggregateFactory, Binder);
	}
}

/// <summary>Convenience extension for executing '{{ ProcedureFullName }}' via an <see cref="IXtraqDbContext"/>.</summary>
public static class {{ ProcedureTypeName }}Extensions
{
	public static async Task<{{ UnifiedResultTypeName }}> {{ ProcedureTypeName }}Async(this IXtraqDbContext db{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		await using var conn = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		return await {{ ProcedureTypeName }}Procedure.ExecuteAsync(db as IXtraqProcedureInterceptorProvider, conn{{#if HasInput}}, input{{/if}}, cancellationToken).ConfigureAwait(false);
	}

{{#each ResultSets as resultSet}}{{#if resultSet.SupportsStreaming}}
	/// <summary>Streams result set <c>{{ resultSet.Name }}</c> without buffering it into the aggregate payload.</summary>
	public static async Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(this IXtraqDbContext db{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, CancellationToken, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(db);
		ArgumentNullException.ThrowIfNull(onRowAsync);
		await using var connection = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		{{#if resultSet.HasOutput}}
		var output = await {{ resultSet.ProcedureTypeName }}Procedure.{{ resultSet.StreamMethodName }}(db as IXtraqProcedureInterceptorProvider, connection{{#if resultSet.HasInput}}, input{{/if}}, onRowAsync, cancellationToken).ConfigureAwait(false);
		return output;
		{{else}}
		await {{ resultSet.ProcedureTypeName }}Procedure.{{ resultSet.StreamMethodName }}(db as IXtraqProcedureInterceptorProvider, connection{{#if resultSet.HasInput}}, input{{/if}}, onRowAsync, cancellationToken).ConfigureAwait(false);
		{{/if}}
	}

	public static Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(this IXtraqDbContext db{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(onRowAsync);
		return {{ resultSet.StreamMethodName }}(db{{#if resultSet.HasInput}}, input{{/if}}, (row, ct) => onRowAsync(row), cancellationToken);
	}

{{/if}}{{/each}}
}

#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API
/// <summary>Minimal API extension for '{{ ProcedureFullName }}'.</summary>
public static class {{ ProcedureTypeName }}RouteHandlerBuilderExtensions
{
    public static RouteHandlerBuilder With{{ ProcedureTypeName }}Procedure(this RouteHandlerBuilder builder)
    {
        ArgumentNullException.ThrowIfNull(builder);

        return builder.WithProcedure<{{#if HasInput}}{{ InputTypeName }}{{else}}object?{{/if}}, {{ UnifiedResultTypeName }}>(
            static pipeline => pipeline.WithExecutor(
                static (dbContext, {{#if HasInput}}input{{else}}_,{{/if}} cancellationToken) => new ValueTask<{{ UnifiedResultTypeName }}>(
                    {{ ProcedureTypeName }}Extensions.{{ ProcedureTypeName }}Async(dbContext{{#if HasInput}}, input{{/if}}, cancellationToken))));
    }
}
#endif

/// <summary>Low-level execution wrapper for a single stored procedure invocation.</summary>
public static class {{ ProcedureTypeName }}Procedure
{
	public const string Name = "{{ ProcedureFullName }}";
	public static Task<{{ UnifiedResultTypeName }}> ExecuteAsync(DbConnection connection{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
		=> ExecuteAsync(null, connection{{#if HasInput}}, input{{/if}}, cancellationToken);

	public static Task<{{ UnifiedResultTypeName }}> ExecuteAsync(IXtraqProcedureInterceptorProvider? interceptorProvider, DbConnection connection{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		return ProcedureExecutor.ExecuteAsync<{{ UnifiedResultTypeName }}>(interceptorProvider, connection, {{ PlanTypeName }}.Instance, {{#if HasInput}}input{{else}}null{{/if}}, cancellationToken);
	}

{{#each ResultSets as resultSet}}{{#if resultSet.SupportsStreaming}}
	/// <summary>Streams result set <c>{{ resultSet.Name }}</c> using the supplied row callback.</summary>
	public static Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(DbConnection connection{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, CancellationToken, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
		=> {{ resultSet.StreamMethodName }}(null, connection{{#if resultSet.HasInput}}, input{{/if}}, onRowAsync, cancellationToken);

	public static async Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(IXtraqProcedureInterceptorProvider? interceptorProvider, DbConnection connection{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, CancellationToken, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(connection);
		ArgumentNullException.ThrowIfNull(onRowAsync);

		async Task StreamCoreAsync(DbDataReader reader, CancellationToken ct)
		{
{{#if resultSet.HasStreamOrdinals}}{{ resultSet.StreamOrdinalDecls }}
{{/if}}			while (await reader.ReadAsync(ct).ConfigureAwait(false))
			{
				var row = {{#if resultSet.HasFieldExpressions}}new {{ resultSet.TypeName }}({{ resultSet.StreamFieldExprs }}){{else}}new {{ resultSet.TypeName }}(){{/if}};
				await onRowAsync(row, ct).ConfigureAwait(false);
			}
		}

{{#if resultSet.HasOutput}}
		var output = await ProcedureExecutor.StreamResultSetAsync(interceptorProvider, connection, {{ resultSet.PlanTypeName }}.Instance, {{ resultSet.StreamIndex }}, StreamCoreAsync, {{#if resultSet.HasInput}}input{{else}}null{{/if}}, cancellationToken).ConfigureAwait(false);
		return ({{ resultSet.OutputTypeName }}?)output;
{{else}}
		await ProcedureExecutor.StreamResultSetAsync(interceptorProvider, connection, {{ resultSet.PlanTypeName }}.Instance, {{ resultSet.StreamIndex }}, StreamCoreAsync, {{#if resultSet.HasInput}}input{{else}}null{{/if}}, cancellationToken).ConfigureAwait(false);
{{/if}}	}

	public static Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(DbConnection connection{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(onRowAsync);
		return {{ resultSet.StreamMethodName }}(null, connection{{#if resultSet.HasInput}}, input{{/if}}, (row, ct) => onRowAsync(row), cancellationToken);
	}

	public static Task{{#if resultSet.HasOutput}}<{{ resultSet.OutputTypeName }}?>{{/if}} {{ resultSet.StreamMethodName }}(IXtraqProcedureInterceptorProvider? interceptorProvider, DbConnection connection{{#if resultSet.HasInput}}, {{ resultSet.InputTypeName }} input{{/if}}, Func<{{ resultSet.TypeName }}, ValueTask> onRowAsync, CancellationToken cancellationToken = default)
	{
		ArgumentNullException.ThrowIfNull(onRowAsync);
		return {{ resultSet.StreamMethodName }}(interceptorProvider, connection{{#if resultSet.HasInput}}, input{{/if}}, (row, ct) => onRowAsync(row), cancellationToken);
	}

{{/if}}{{/each}}
}
