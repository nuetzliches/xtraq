using Xtraq.Utils;

namespace Xtraq.Engine;

/// <summary>
/// Centralizes template access concerns (header resolution, lookup, rendering) so generators
/// can rely on a shared abstraction instead of duplicating boilerplate logic.
/// </summary>
public sealed class TemplateCoordinator
{
    private readonly ITemplateRenderer _renderer;
    private readonly ITemplateLoader? _loader;
    private readonly Lazy<string> _header;

    /// <summary>
    /// Initializes a new instance of the <see cref="TemplateCoordinator"/> class.
    /// </summary>
    /// <param name="renderer">The renderer responsible for expanding template content.</param>
    /// <param name="loader">The optional loader used to resolve named templates.</param>
    public TemplateCoordinator(ITemplateRenderer renderer, ITemplateLoader? loader)
    {
        _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));
        _loader = loader;
        _header = new Lazy<string>(ResolveHeader, LazyThreadSafetyMode.ExecutionAndPublication);
    }

    /// <summary>
    /// Returns the resolved generator header comment (falls back to a default when no template exists).
    /// </summary>
    public string Header => _header.Value;

    /// <summary>
    /// Returns the header followed by a newline when available (useful for template substitution).
    /// </summary>
    public string HeaderBlock => Header.Length == 0 ? string.Empty : Header + Environment.NewLine;

    /// <summary>
    /// Tries to load a template by name.
    /// </summary>
    /// <param name="templateName">The logical template name to locate.</param>
    /// <param name="template">When the method returns <c>true</c>, contains the resolved template content.</param>
    /// <returns><c>true</c> when a matching template exists; otherwise <c>false</c>.</returns>
    public bool TryLoad(string templateName, out string template)
    {
        if (_loader is null)
        {
            template = string.Empty;
            return false;
        }

        return _loader.TryLoad(templateName, out template);
    }

    /// <summary>
    /// Lists all template names exposed by the underlying loader.
    /// </summary>
    /// <returns>The logical template names supplied by the loader, or an empty sequence when no loader is configured.</returns>
    public IEnumerable<string> ListNames()
        => _loader?.ListNames() ?? Array.Empty<string>();

    /// <summary>
    /// Renders a template by name, falling back to the supplied template when the loader has no match.
    /// </summary>
    /// <param name="templateName">The logical template name to render.</param>
    /// <param name="model">The data model supplied to the template.</param>
    /// <param name="fallbackTemplate">Optional inline template to use when the loader cannot resolve the name.</param>
    /// <returns>The rendered template text.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the template is missing and no fallback is provided.</exception>
    public string RenderTemplate(string templateName, object model, string? fallbackTemplate = null)
    {
        if (_loader != null && _loader.TryLoad(templateName, out var template))
        {
            return RenderRawTemplate(template, model);
        }

        if (fallbackTemplate is not null)
        {
            return RenderRawTemplate(fallbackTemplate, model);
        }

        throw new InvalidOperationException($"Template '{templateName}' was not found by the current template loader.");
    }

    /// <summary>
    /// Renders the provided template content with the given model.
    /// </summary>
    /// <param name="template">The template text to render.</param>
    /// <param name="model">The data model used during rendering.</param>
    /// <returns>The rendered template output.</returns>
    public string RenderRawTemplate(string template, object model)
        => _renderer.Render(template, model);

    private string ResolveHeader()
    {
        if (_loader != null && _loader.TryLoad("_Header", out var headerTpl))
        {
            try
            {
                var rendered = _renderer.Render(headerTpl, new { GeneratorLabel = GeneratorBranding.Label });
                return rendered.TrimEnd();
            }
            catch
            {
                // Fallback below when rendering fails (e.g., malformed template).
            }
        }

        return "// <auto-generated/>\n// Generated by " + GeneratorBranding.Label + ". Changes may be overwritten.";
    }
}
