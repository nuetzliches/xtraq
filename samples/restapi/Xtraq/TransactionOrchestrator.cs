// <auto-generated/>
// Xtraq Code Generator. Do not edit this file directly.
// Changes may be overwritten. For customization extend generated partials.

#nullable enable
namespace Xtraq.Samples.RestApi.Xtraq;

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public interface IXtraqTransactionOrchestrator
{
    bool HasActiveTransaction { get; }
    DbConnection? CurrentConnection { get; }
    DbTransaction? CurrentTransaction { get; }
    ValueTask<XtraqTransactionScope> BeginAsync(XtraqTransactionOptions? options = null, CancellationToken cancellationToken = default);
}

public interface IXtraqTransactionOrchestratorAccessor
{
    IXtraqTransactionOrchestrator TransactionOrchestrator { get; }
}

public interface IXtraqAmbientTransactionAccessor
{
    DbTransaction? AmbientTransaction { get; }
    DbConnection? AmbientConnection { get; }
}

public sealed record class XtraqTransactionOptions
{
    public IsolationLevel? IsolationLevel { get; init; }
    public bool RequiresNew { get; init; }
    public static XtraqTransactionOptions Default { get; } = new();
}

public sealed class XtraqTransactionOrchestrator : IXtraqTransactionOrchestrator
{
    private readonly IXtraqDbContext _dbContext;
    private readonly SemaphoreSlim _gate = new(1, 1);
    private readonly Stack<XtraqTransactionScopeState> _scopes = new();
    private DbConnection? _connection;
    private long _scopeId;
    private int _savepointCounter;

    public XtraqTransactionOrchestrator(IXtraqDbContext dbContext)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
    }

    public bool HasActiveTransaction => _scopes.Count > 0;
    public DbConnection? CurrentConnection => _connection;
    public DbTransaction? CurrentTransaction => _scopes.Count > 0 ? _scopes.Peek().Transaction : null;

    public async ValueTask<XtraqTransactionScope> BeginAsync(XtraqTransactionOptions? options = null, CancellationToken cancellationToken = default)
    {
        options ??= XtraqTransactionOptions.Default;

        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            XtraqTransactionScopeState state;
            if (_scopes.Count == 0)
            {
                if (TryAcquireAmbientTransaction(out var ambientConnection, out var ambientTransaction))
                {
                    _connection = ambientConnection;
                    state = new XtraqTransactionScopeState(
                        ++_scopeId,
                        ambientConnection,
                        ambientTransaction,
                        null,
                        isRoot: true,
                        ownsConnection: false,
                        ownsTransaction: false,
                        isExternal: true);
                }
                else
                {
                    if (_connection is null)
                    {
                        _connection = await _dbContext.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
                    }

                    if (_connection.State != ConnectionState.Open)
                    {
                        await _connection.OpenAsync(cancellationToken).ConfigureAwait(false);
                    }

                    var isolation = options.IsolationLevel ?? IsolationLevel.ReadCommitted;
                    var transaction = await BeginTransactionAsync(_connection, isolation, cancellationToken).ConfigureAwait(false);
                    state = new XtraqTransactionScopeState(
                        ++_scopeId,
                        _connection,
                        transaction,
                        null,
                        isRoot: true,
                        ownsConnection: true,
                        ownsTransaction: true,
                        isExternal: false);
                }
            }
            else if (options.RequiresNew)
            {
                var parent = _scopes.Peek();
                var connection = await _dbContext.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
                if (connection.State != ConnectionState.Open)
                {
                    await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
                }

                var isolation = options.IsolationLevel ?? IsolationLevel.ReadCommitted;
                var transaction = await BeginTransactionAsync(connection, isolation, cancellationToken).ConfigureAwait(false);
                var ownsConnection = !ReferenceEquals(connection, parent.Connection);
                state = new XtraqTransactionScopeState(
                    ++_scopeId,
                    connection,
                    transaction,
                    null,
                    isRoot: false,
                    ownsConnection: ownsConnection,
                    ownsTransaction: true,
                    isExternal: false);
            }
            else
            {
                var parent = _scopes.Peek();
                var savepoint = GenerateSavepointName();
                parent.Transaction.Save(savepoint);
                state = new XtraqTransactionScopeState(
                    ++_scopeId,
                    parent.Connection,
                    parent.Transaction,
                    savepoint,
                    isRoot: false,
                    ownsConnection: false,
                    ownsTransaction: false,
                    isExternal: false);
            }

            _scopes.Push(state);
            return new XtraqTransactionScope(this, state, state.Connection, state.Transaction);
        }
        finally
        {
            _gate.Release();
        }
    }

    internal async ValueTask CommitAsync(XtraqTransactionScopeState state, CancellationToken cancellationToken)
    {
        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            EnsureCurrentScope(state);

            if (state.Status == XtraqTransactionScopeStatus.Committed)
            {
                return;
            }

            if (state.Status == XtraqTransactionScopeStatus.RolledBack)
            {
                throw new InvalidOperationException("Cannot commit a scope that has already been rolled back.");
            }

            if (state.IsRoot)
            {
                if (!state.IsExternal)
                {
                    state.Transaction.Commit();
                }

                state.MarkCommitted();
                _scopes.Pop();
                if (state.OwnsTransaction)
                {
                    await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                }

                await ReleaseRootConnectionAsync(state).ConfigureAwait(false);
            }
            else if (state.UsesSavepoint)
            {
                state.MarkCommitted();
                _scopes.Pop();
            }
            else
            {
                state.Transaction.Commit();
                state.MarkCommitted();
                _scopes.Pop();
                if (state.OwnsTransaction)
                {
                    await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                }
                if (state.OwnsConnection)
                {
                    await DisposeOwnedConnectionAsync(state.Connection).ConfigureAwait(false);
                }
            }
        }
        finally
        {
            _gate.Release();
        }
    }

    internal async ValueTask RollbackAsync(XtraqTransactionScopeState state, CancellationToken cancellationToken)
    {
        await _gate.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            EnsureCurrentScope(state);

            if (state.Status == XtraqTransactionScopeStatus.RolledBack)
            {
                return;
            }

            if (state.Status == XtraqTransactionScopeStatus.Committed)
            {
                throw new InvalidOperationException("Cannot roll back a scope that has already been committed.");
            }

            if (state.IsRoot)
            {
                state.Transaction.Rollback();
                state.MarkRolledBack();
                _scopes.Pop();
                if (state.OwnsTransaction)
                {
                    await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                }

                await ReleaseRootConnectionAsync(state).ConfigureAwait(false);
            }
            else if (state.UsesSavepoint)
            {
                state.Transaction.Rollback(state.SavepointName!);
                state.MarkRolledBack();
                _scopes.Pop();
            }
            else
            {
                state.Transaction.Rollback();
                state.MarkRolledBack();
                _scopes.Pop();
                if (state.OwnsTransaction)
                {
                    await DisposeTransactionAsync(state.Transaction).ConfigureAwait(false);
                }

                if (state.OwnsConnection)
                {
                    await DisposeOwnedConnectionAsync(state.Connection).ConfigureAwait(false);
                }
            }
        }
        finally
        {
            _gate.Release();
        }
    }

    internal ValueTask DisposeScopeAsync(XtraqTransactionScopeState state)
    {
        if (state.Status == XtraqTransactionScopeStatus.Active)
        {
            return RollbackAsync(state, CancellationToken.None);
        }

        return ValueTask.CompletedTask;
    }

    private void EnsureCurrentScope(XtraqTransactionScopeState state)
    {
        if (_scopes.Count == 0 || !ReferenceEquals(_scopes.Peek(), state))
        {
            throw new InvalidOperationException("Transaction scopes must be completed in LIFO order.");
        }
    }

    private string GenerateSavepointName()
    {
        var value = Interlocked.Increment(ref _savepointCounter);
        return FormattableString.Invariant($"xtraq_sp_{value}");
    }

    private static ValueTask<DbTransaction> BeginTransactionAsync(DbConnection connection, IsolationLevel isolationLevel, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return new(connection.BeginTransaction(isolationLevel));
    }

    private static ValueTask DisposeTransactionAsync(DbTransaction transaction)
    {
        if (transaction is IAsyncDisposable asyncDisposable)
        {
            return asyncDisposable.DisposeAsync();
        }

        transaction.Dispose();
        return ValueTask.CompletedTask;
    }

    private static ValueTask DisposeOwnedConnectionAsync(DbConnection connection)
    {
        if (connection is IAsyncDisposable asyncDisposable)
        {
            return asyncDisposable.DisposeAsync();
        }

        connection.Dispose();
        return ValueTask.CompletedTask;
    }

    private bool TryAcquireAmbientTransaction(out DbConnection connection, out DbTransaction transaction)
    {
        connection = default!;
        transaction = default!;

        if (_dbContext is not IXtraqAmbientTransactionAccessor accessor)
        {
            return false;
        }

        var ambientTransaction = accessor.AmbientTransaction;
        if (ambientTransaction is null)
        {
            return false;
        }

        var ambientConnection = accessor.AmbientConnection ?? ambientTransaction.Connection;
        if (ambientConnection is null)
        {
            return false;
        }

        connection = ambientConnection;
        transaction = ambientTransaction;
        return true;
    }

    private ValueTask ReleaseRootConnectionAsync(XtraqTransactionScopeState state)
    {
        if (!ReferenceEquals(_connection, state.Connection))
        {
            return ValueTask.CompletedTask;
        }

        var connection = _connection;
        _connection = null;

        if (!state.OwnsConnection || connection is null)
        {
            return ValueTask.CompletedTask;
        }

        return DisposeOwnedConnectionAsync(connection);
    }
}

public sealed class XtraqTransactionScope : IAsyncDisposable
{
    private readonly XtraqTransactionOrchestrator _owner;
    private readonly XtraqTransactionScopeState _state;
    private int _disposed;

    internal XtraqTransactionScope(
        XtraqTransactionOrchestrator owner,
        XtraqTransactionScopeState state,
        DbConnection connection,
        DbTransaction transaction)
    {
        _owner = owner;
        _state = state;
        Connection = connection;
        Transaction = transaction;
    }

    public DbConnection Connection { get; }
    public DbTransaction Transaction { get; }
    public bool IsRoot => _state.IsRoot;

    public ValueTask CommitAsync(CancellationToken cancellationToken = default)
        => _owner.CommitAsync(_state, cancellationToken);

    public ValueTask RollbackAsync(CancellationToken cancellationToken = default)
        => _owner.RollbackAsync(_state, cancellationToken);

    public async ValueTask DisposeAsync()
    {
        if (Interlocked.Exchange(ref _disposed, 1) != 0)
        {
            return;
        }

        await _owner.DisposeScopeAsync(_state).ConfigureAwait(false);
    }
}

internal enum XtraqTransactionScopeStatus
{
    Active,
    Committed,
    RolledBack
}

internal sealed class XtraqTransactionScopeState
{
    public XtraqTransactionScopeState(
        long id,
        DbConnection connection,
        DbTransaction transaction,
        string? savepointName,
        bool isRoot,
        bool ownsConnection,
        bool ownsTransaction,
        bool isExternal)
    {
        Id = id;
        Connection = connection;
        Transaction = transaction;
        SavepointName = savepointName;
        IsRoot = isRoot;
        OwnsConnection = ownsConnection;
        OwnsTransaction = ownsTransaction;
        IsExternal = isExternal;
        Status = XtraqTransactionScopeStatus.Active;
    }

    public long Id { get; }
    public DbConnection Connection { get; }
    public DbTransaction Transaction { get; }
    public string? SavepointName { get; }
    public bool IsRoot { get; }
    public bool OwnsConnection { get; }
    public bool OwnsTransaction { get; }
    public bool IsExternal { get; }
    public XtraqTransactionScopeStatus Status { get; private set; }
    public bool UsesSavepoint => SavepointName is not null;

    public void MarkCommitted() => Status = XtraqTransactionScopeStatus.Committed;
    public void MarkRolledBack() => Status = XtraqTransactionScopeStatus.RolledBack;
}
