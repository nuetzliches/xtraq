---
title: Entity Framework Integration
description: Bridge the Xtraq transaction orchestrator with existing Entity Framework Core DbContext scopes.
---

## Overview

Xtraq exposes a scoped transaction orchestrator that keeps a shared connection per request, supports nested savepoints, and can spawn `RequiresNew` scopes on demand. When an application already uses Entity Framework Core, the generated project now ships a `UseXtraqProcedures<TDbContext>()` extension that wires stored procedure execution into the active EF Core `DbContext` scope.

The adapter automatically:

- Reuses the ambient EF Core transaction through `IXtraqAmbientTransactionAccessor` so generated procedures participate in the same commit/rollback cycle.
- Falls back to opening a dedicated connection (using the configured Xtraq connection string) when no EF transaction is active.
- Mirrors EF Core command timeout configuration, with `XtraqDbContextOptions.CommandTimeout` as an explicit override.

## Registering the Integration

Call the extension after registering your DbContext and the generated Xtraq services:

```csharp
builder.Services.AddDbContext<AppDbContext>(options =>
{
  options.UseSqlServer(connectionString);
});

builder.Services.AddXtraqDbContext(options =>
{
  options.ConnectionString = connectionString;
});

builder.Services.UseXtraqProcedures<AppDbContext>();
```

The helper replaces the default `IXtraqDbContext` registration with an adapter that resolves the scoped `AppDbContext`. The transaction orchestrator detects when the adapter reports an ambient transaction and skips disposing EF-owned resources; when no transaction is present it creates a fresh connection that still benefits from SQL Server connection pooling.

## Customising the Adapter

The generated adapter is an internal class named `EntityFrameworkXtraqContext<TDbContext>`. Add a partial declaration to change behaviour—for example, to decorate the health check or expose additional diagnostics:

```csharp
namespace MyCompany.Xtraq;

internal sealed partial class EntityFrameworkXtraqContext<TDbContext>
{
  partial void OnConnectionOpened(DbConnection connection)
  {
    Console.WriteLine($"Opened Xtraq connection {connection.DataSource}");
  }
}
```

> **Note**: Hook points are surfaced via the `OnConnectionOpened` and `OnAmbientConnectionResolved` partial methods generated in the adapter. Avoid mutating the EF DbContext outside these hooks to keep the lifetime aligned with the DI scope.

## Mapping Result Sets to Entities

`UseXtraqProcedures<TDbContext>()` also registers `ProcedureResultEntityAdapter<TDbContext>` so strongly typed procedure rows can be projected into tracked EF entities or keyless query types without hand-written mappers:

```csharp
var adapter = scope.ServiceProvider.GetRequiredService<ProcedureResultEntityAdapter<AppDbContext>>();

// Attach tracked entities using primary-key matching (row names are normalised case-insensitively).
var banners = adapter.AttachEntities<Banner, BannerProcedure.ResultRow>(result.Result);

// Materialise keyless types (not tracked by the change tracker).
var metrics = adapter.ProjectKeyless<ProcedureMetric, MetricsProcedure.ResultRow>(result.Metrics);
```

- Property names are normalised by removing `_` and applying ordinal-insensitive matching (`bannerId` → `BannerId`).
- When row shapes diverge from entity keys, supply a custom key resolver: `adapter.AttachEntities<Banner, BannerRow>(rows, keyResolver: row => new object?[] { row.Id, row.TenantId });`
- Provide a custom projector to override the built-in reflection mapper: `adapter.AttachEntities<Banner, BannerRow>(rows, (entity, row) => entity.UpdateFrom(row));`
- Pass `EntityState.Modified` as the `state` parameter when the rows should mark entities as changed for update pipelines.

Keyless projections remain detached; use them to hydrate query types or DTO-style read models while the tracked entity mapping keeps the ambient context in sync with stored procedure output.

## Usage Guidelines

- Resolve the EF `DbContext` and `IXtraqDbContext` inside the same request scope (for example per HTTP request).
- Call `BeginAsync` only when you need an explicit scope; otherwise generated procedures automatically join the ambient EF transaction detected by the adapter.
- Use `RequiresNew` for work that must run outside the ambient transaction (for example audit trails or idempotency checkpoints).
- When EF does not expose a current transaction, the adapter opens a new SQL Server connection using the configured Xtraq connection string and the orchestrator disposes it after the scope completes.
- Set `XtraqDbContextOptions.CommandTimeout` to override EF Core defaults for procedure execution.

## Additional Resources

- [Transaction API roadmap entry](../5.roadmap/index.md#transaction-api)
