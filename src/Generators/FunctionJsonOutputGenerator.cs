using Xtraq.Configuration;
using Xtraq.Engine;
using Xtraq.Metadata;
using Xtraq.Utils;

namespace Xtraq.Generators;

/// <summary>
/// Generates strongly-typed record structs for JSON-emitting scalar functions (e.g., identity.RecordAsJson).
/// </summary>
internal sealed class FunctionJsonOutputGenerator : GeneratorBase
{
    public FunctionJsonOutputGenerator(ITemplateRenderer renderer, ITemplateLoader? loader = null, XtraqConfiguration? cfg = null)
        : base(renderer, loader, cfg)
    {
    }

    public int Generate(string baseNamespace, string baseOutputDir, IReadOnlyList<FunctionJsonDescriptor> descriptors)
    {
        if (descriptors == null || descriptors.Count == 0)
        {
            return 0;
        }

        var header = Templates.Header;
        var emitJsonIncludeNullValues = ShouldEmitJsonIncludeNullValues();
        var written = 0;
        foreach (var descriptor in descriptors.OrderBy(d => d.SchemaName, StringComparer.OrdinalIgnoreCase)
                                              .ThenBy(d => d.FunctionName, StringComparer.OrdinalIgnoreCase))
        {
            var schemaSegment = ToPascalCase(descriptor.SchemaName);
            var ns = $"{baseNamespace}.{schemaSegment}";
            var schemaDir = Path.Combine(baseOutputDir, schemaSegment);
            Directory.CreateDirectory(schemaDir);

            var typeDefinitions = new List<string>();
            BuildTypeDefinitions(descriptor.RootTypeName, descriptor.Fields, typeDefinitions, emitJsonIncludeNullValues);

            var fileBuilder = new StringBuilder();
            if (!string.IsNullOrWhiteSpace(header))
            {
                fileBuilder.AppendLine(header);
            }
            else
            {
                fileBuilder.AppendLine("// <auto-generated/>");
                fileBuilder.AppendLine($"// Generated by {GeneratorBranding.Label}. Changes may be overwritten.");
            }
            fileBuilder.AppendLine();
            fileBuilder.AppendLine("#nullable enable");
            fileBuilder.AppendLine($"namespace {ns};");
            fileBuilder.AppendLine();

            foreach (var typeDef in typeDefinitions)
            {
                fileBuilder.AppendLine(typeDef);
                fileBuilder.AppendLine();
            }

            var filePath = Path.Combine(schemaDir, descriptor.RootTypeName + ".cs");
            File.WriteAllText(filePath, fileBuilder.ToString().TrimEnd() + Environment.NewLine);
            written++;
        }

        return written;
    }

    private static void BuildTypeDefinitions(string typeName, IReadOnlyList<FunctionJsonFieldDescriptor> fields, List<string> collector, bool emitJsonIncludeNullValues)
    {
        if (fields == null)
        {
            return;
        }

        foreach (var field in fields.Where(static f => f.IsContainer))
        {
            var childTypeName = typeName + ToPascalCase(field.Name) + "Result";
            BuildTypeDefinitions(childTypeName, field.Children, collector, emitJsonIncludeNullValues);
        }

        collector.Add(RenderRecordType(typeName, fields, emitJsonIncludeNullValues));
    }

    private static string RenderRecordType(string typeName, IReadOnlyList<FunctionJsonFieldDescriptor> fields, bool emitJsonIncludeNullValues)
    {
        var builder = new StringBuilder();

        if (fields == null || fields.Count == 0)
        {
            builder.AppendLine($"public readonly record struct {typeName}();");
            return builder.ToString();
        }

        builder.AppendLine($"public readonly record struct {typeName}(");

        var usedNames = new HashSet<string>(StringComparer.Ordinal);
        for (var i = 0; i < fields.Count; i++)
        {
            var field = fields[i];
            var propertyName = AliasToIdentifier(field.Name);
            if (!usedNames.Add(propertyName))
            {
                var suffix = 1;
                while (!usedNames.Add(propertyName + suffix)) suffix++;
                propertyName += suffix;
            }

            var propertyType = ResolveTypeLiteral(typeName, field);
            var attribute = emitJsonIncludeNullValues && field.IncludeNullValues
                ? "    [property: JsonIncludeNullValues]" + Environment.NewLine
                : string.Empty;
            if (attribute.Length > 0)
            {
                builder.Append(attribute);
            }

            builder.Append("    ");
            builder.Append(propertyType);
            builder.Append(' ');
            builder.Append(propertyName);
            if (i < fields.Count - 1)
            {
                builder.Append(',');
            }

            builder.AppendLine();
        }

        builder.AppendLine(");");
        return builder.ToString();
    }

    private static string ResolveTypeLiteral(string parentTypeName, FunctionJsonFieldDescriptor field)
    {
        if (field.IsContainer)
        {
            var childTypeName = parentTypeName + ToPascalCase(field.Name) + "Result";
            var containerType = field.IsArray
                ? $"System.Collections.Generic.List<{childTypeName}>"
                : childTypeName;
            return ApplyNullability(containerType, field.IsNullable);
        }

        return ApplyNullability(field.ClrType ?? "string", field.IsNullable);
    }

    private static string ApplyNullability(string typeName, bool nullable)
    {
        var trimmed = string.IsNullOrWhiteSpace(typeName) ? string.Empty : typeName.Trim();
        if (!nullable || trimmed.Length == 0)
        {
            return trimmed;
        }

        if (trimmed.EndsWith("?", StringComparison.Ordinal))
        {
            return trimmed;
        }

        if (trimmed.EndsWith("[]", StringComparison.Ordinal))
        {
            return trimmed + "?";
        }

        return trimmed + "?";
    }

    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        var parts = input.Split(new[] { '-', '_', ' ', '.', '/', '\\' }, StringSplitOptions.RemoveEmptyEntries)
                         .Select(static p => p.Trim())
                         .Where(static p => p.Length > 0)
                         .Select(static p => char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p.Substring(1).ToLowerInvariant() : string.Empty));

        var candidate = string.Concat(parts);
        candidate = new string(candidate.Where(static ch => char.IsLetterOrDigit(ch) || ch == '_').ToArray());
        if (candidate.Length == 0)
        {
            candidate = "Schema";
        }

        if (char.IsDigit(candidate[0]))
        {
            candidate = "N" + candidate;
        }

        return candidate;
    }

    private static string AliasToIdentifier(string alias)
    {
        if (string.IsNullOrWhiteSpace(alias)) return "_";

        var builder = new StringBuilder(alias.Length);
        for (var i = 0; i < alias.Length; i++)
        {
            var ch = alias[i];
            if (i == 0)
            {
                builder.Append(char.IsLetter(ch) || ch == '_' ? ch : '_');
            }
            else
            {
                builder.Append(char.IsLetterOrDigit(ch) || ch == '_' ? ch : '_');
            }
        }

        var ident = builder.ToString();
        if (ident.Length == 0)
        {
            ident = "_";
        }

        if (char.IsDigit(ident[0]))
        {
            ident = "_" + ident;
        }

        if (IsCSharpKeyword(ident))
        {
            ident = "@" + ident;
        }

        return ident;
    }

    private static readonly HashSet<string> CSharpKeywords = new(new[]
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const","continue","decimal","default","delegate","do","double","else","enum","event","explicit","extern","false","finally","fixed","float","for","foreach","goto","if","implicit","in","int","interface","internal","is","lock","long","namespace","new","null","object","operator","out","override","params","private","protected","public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static","string","struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked","unsafe","ushort","using","virtual","void","volatile","while"
    }, StringComparer.Ordinal);

    private static bool IsCSharpKeyword(string ident) => CSharpKeywords.Contains(ident);
}
