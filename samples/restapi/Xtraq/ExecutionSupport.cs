// <auto-generated/>
// Xtraq Code Generator. Do not edit this file directly.
// Changes may be overwritten. For customization extend generated partials.

#nullable enable
namespace Xtraq.Samples.RestApi.Xtraq;

using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using System.Reflection;
using System.Data;
using System.Linq;
using Microsoft.Data.SqlClient;
using Microsoft.Data.SqlClient.Server;
using System.Buffers;

internal sealed class ProcedureParameter
{
    public ProcedureParameter(string name, System.Data.DbType dbType, object? size, bool isOutput, bool isNullable)
    { Name = name; DbType = dbType; Size = size; IsOutput = isOutput; IsNullable = isNullable; }
    public string Name { get; }
    public System.Data.DbType DbType { get; }
    public object? Size { get; }
    public bool IsOutput { get; }
    public bool IsNullable { get; }
}

internal sealed class ResultSetMapping
{
    public ResultSetMapping(string name, Func<DbDataReader, CancellationToken, Task<List<object>>> projector)
    { Name = name; Projector = projector; }
    public string Name { get; }
    public Func<DbDataReader, CancellationToken, Task<List<object>>> Projector { get; }
}

internal sealed class ProcedureExecutionPlan
{
    public ProcedureExecutionPlan(string name, ProcedureParameter[] parameters, ResultSetMapping[] resultSets,
        Func<IReadOnlyDictionary<string, object?>, object?> outputFactory,
        Func<bool,string?,object?,IReadOnlyDictionary<string,object?>,object[],object> aggregateFactory,
        Action<DbCommand,object?> binder)
    { Name = name; Parameters = parameters; ResultSets = resultSets; OutputFactory = outputFactory; AggregateFactory = aggregateFactory; Binder = binder; }
    public string Name { get; }
    public ProcedureParameter[] Parameters { get; }
    public ResultSetMapping[] ResultSets { get; }
    public Func<IReadOnlyDictionary<string, object?>, object?> OutputFactory { get; }
    public Func<bool,string?,object?,IReadOnlyDictionary<string,object?>,object[],object> AggregateFactory { get; }
    public Action<DbCommand,object?> Binder { get; }
}

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter)]
internal sealed class JsonIncludeNullValuesAttribute : Attribute
{
}

// Global JSON options used when per-result-set deserialization is required (the projector has no access to the DbContext options instance)
internal static class JsonSupport
{
    // Converter: allows number/bool/null tokens for string properties without throwing.
    private sealed class LenientStringConverter : System.Text.Json.Serialization.JsonConverter<string>
    {
        public override string Read(ref System.Text.Json.Utf8JsonReader reader, Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {
            return reader.TokenType switch
            {
                System.Text.Json.JsonTokenType.String => reader.GetString()!,
                System.Text.Json.JsonTokenType.Number => reader.TryGetInt64(out var l) ? l.ToString() : reader.TryGetDouble(out var d) ? d.ToString(System.Globalization.CultureInfo.InvariantCulture) : GetSpanString(ref reader),
                System.Text.Json.JsonTokenType.True => "true",
                System.Text.Json.JsonTokenType.False => "false",
                System.Text.Json.JsonTokenType.Null => string.Empty,
                _ => string.Empty
            };
        }
        public override void Write(System.Text.Json.Utf8JsonWriter writer, string value, System.Text.Json.JsonSerializerOptions options)
        {
            writer.WriteStringValue(value);
        }
        private static string GetSpanString(ref System.Text.Json.Utf8JsonReader reader)
        {
            try
            {
                if (reader.HasValueSequence)
                {
                    var seq = reader.ValueSequence; // ReadOnlySequence<byte>
                    if (seq.IsSingleSegment)
                    {
                        return System.Text.Encoding.UTF8.GetString(seq.FirstSpan);
                    }
                    var buffer = new byte[seq.Length];
                    seq.CopyTo(buffer);
                    return System.Text.Encoding.UTF8.GetString(buffer);
                }
                return System.Text.Encoding.UTF8.GetString(reader.ValueSpan);
            }
            catch { return string.Empty; }
        }
    }
    public static readonly System.Text.Json.JsonSerializerOptions Options = new()
    {
        PropertyNameCaseInsensitive = true,
        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull,
        NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString
    };
    public static TElement[]? DeserializeArray<TElement>(string raw, bool allowNull)
    {
        if (string.IsNullOrWhiteSpace(raw))
        {
            return allowNull ? null : Array.Empty<TElement>();
        }

        try
        {
            var result = System.Text.Json.JsonSerializer.Deserialize<TElement[]>(raw, Options);
            if (result == null)
            {
                return allowNull ? null : Array.Empty<TElement>();
            }

            return result;
        }
        catch
        {
            return allowNull ? null : Array.Empty<TElement>();
        }
    }
    static JsonSupport()
    {
        Options.Converters.Add(new LenientStringConverter());
        var resolver = new System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver();
        resolver.Modifiers.Add(ApplyJsonIncludeNullValues);
        Options.TypeInfoResolver = resolver;
    }

    private static void ApplyJsonIncludeNullValues(System.Text.Json.Serialization.Metadata.JsonTypeInfo typeInfo)
    {
        if (typeInfo.Kind != System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object)
        {
            return;
        }

        foreach (var property in typeInfo.Properties)
        {
            if (property.AttributeProvider?.IsDefined(typeof(JsonIncludeNullValuesAttribute), inherit: true) == true)
            {
                var metaType = property.GetType();
                const BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

                var ignoreCondition = metaType.GetProperty("IgnoreCondition", flags);
                if (ignoreCondition?.CanWrite == true)
                {
                    ignoreCondition.SetValue(property, System.Text.Json.Serialization.JsonIgnoreCondition.Never);
                    continue;
                }

                var defaultIgnoreCondition = metaType.GetProperty("DefaultIgnoreCondition", flags);
                if (defaultIgnoreCondition?.CanWrite == true)
                {
                    defaultIgnoreCondition.SetValue(property, System.Text.Json.Serialization.JsonIgnoreCondition.Never);
                }
            }
        }
    }
}

internal sealed class JsonResultEnvelope<T>
{
    private readonly IReadOnlyList<T> _items;

    private JsonResultEnvelope(IReadOnlyList<T> items, string? rawJson)
    {
        _items = items ?? Array.Empty<T>();
        RawJson = rawJson;
    }

    public static JsonResultEnvelope<T> Create(IEnumerable<T> items, string? rawJson)
    {
        if (items is IReadOnlyList<T> list)
        {
            return new JsonResultEnvelope<T>(list, rawJson);
        }

        return new JsonResultEnvelope<T>(items?.ToArray() ?? Array.Empty<T>(), rawJson);
    }

    public IReadOnlyList<T> Items => _items;

    public string? RawJson { get; }

    public bool TryGetFirst(out T value)
    {
        if (_items.Count > 0)
        {
            value = _items[0];
            return true;
        }

        value = default!;
        return false;
    }
}

internal static class ProcedureExecutor
{
    public static Task<T> ExecuteAsync<T>(DbConnection connection, ProcedureExecutionPlan plan, object? input, CancellationToken ct)
        => ExecuteAsync<T>(null, connection, plan, input, ct);

    public static async Task<T> ExecuteAsync<T>(IXtraqProcedureInterceptorProvider? interceptorProvider, DbConnection connection, ProcedureExecutionPlan plan, object? input, CancellationToken ct)
    {
        if (connection == null) throw new ArgumentNullException(nameof(connection));
        if (plan == null) throw new ArgumentNullException(nameof(plan));

        await using var cmd = connection.CreateCommand();
        cmd.CommandText = plan.Name;
        cmd.CommandType = System.Data.CommandType.StoredProcedure;
        foreach (var p in plan.Parameters)
        {
            var prm = cmd.CreateParameter();
            prm.ParameterName = p.Name;
            prm.DbType = p.DbType;
            if (p.Size is int s && s > 0) prm.Size = s;
            prm.Direction = p.IsOutput ? System.Data.ParameterDirection.InputOutput : System.Data.ParameterDirection.Input;
            prm.Value = DBNull.Value;
            cmd.Parameters.Add(prm);
        }

        var interceptors = await InvokeBeforeAsync(interceptorProvider, plan.Name, cmd, input, ct).ConfigureAwait(false);
        var start = DateTime.UtcNow;

        try
        {
            if (connection.State != ConnectionState.Open)
            {
                await connection.OpenAsync(ct).ConfigureAwait(false);
            }

            plan.Binder(cmd, input);

            await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
            var rsResults = new List<object>(plan.ResultSets.Length);
            for (int i = 0; i < plan.ResultSets.Length; i++)
            {
                var list = await plan.ResultSets[i].Projector(reader, ct).ConfigureAwait(false);
                rsResults.Add(list);
                if (i < plan.ResultSets.Length - 1)
                {
                    if (!await reader.NextResultAsync(ct).ConfigureAwait(false))
                    {
                        break;
                    }
                }
            }

            var outputs = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
            foreach (DbParameter dbp in cmd.Parameters)
            {
                if (dbp.Direction.HasFlag(System.Data.ParameterDirection.Output) || dbp.Direction.HasFlag(System.Data.ParameterDirection.InputOutput))
                {
                    var key = dbp.ParameterName.TrimStart('@');
                    outputs[key] = dbp.Value == DBNull.Value ? null : dbp.Value;
                }
            }

            var outputObj = plan.OutputFactory(outputs);
            var rsArrays = new object[rsResults.Count];
            for (int i = 0; i < rsResults.Count; i++)
            {
                rsArrays[i] = ((List<object>)rsResults[i]).ToArray();
            }

            var aggregate = (T)plan.AggregateFactory(true, null, outputObj, outputs, rsArrays);
            var duration = DateTime.UtcNow - start;
            await NotifyAfterAsync(interceptors, plan.Name, cmd, true, null, duration, aggregate, ct).ConfigureAwait(false);
            return aggregate;
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - start;
            try
            {
                await NotifyAfterAsync(interceptors, plan.Name, cmd, false, ex.Message, duration, null, ct).ConfigureAwait(false);
            }
            catch
            {
                // Deliberately swallow interceptor failures on the failure path.
            }

            throw;
        }
    }

    public static Task<object?> StreamResultSetAsync(DbConnection connection, ProcedureExecutionPlan plan, int resultSetIndex, Func<DbDataReader, CancellationToken, Task> streamAction, object? input, CancellationToken ct)
        => StreamResultSetAsync(null, connection, plan, resultSetIndex, streamAction, input, ct);

    public static async Task<object?> StreamResultSetAsync(IXtraqProcedureInterceptorProvider? interceptorProvider, DbConnection connection, ProcedureExecutionPlan plan, int resultSetIndex, Func<DbDataReader, CancellationToken, Task> streamAction, object? input, CancellationToken ct)
    {
        if (connection == null) throw new ArgumentNullException(nameof(connection));
        if (plan == null) throw new ArgumentNullException(nameof(plan));
        if (streamAction == null) throw new ArgumentNullException(nameof(streamAction));
        if (resultSetIndex < 0 || resultSetIndex >= plan.ResultSets.Length) throw new ArgumentOutOfRangeException(nameof(resultSetIndex));

        await using var cmd = connection.CreateCommand();
        cmd.CommandText = plan.Name;
        cmd.CommandType = System.Data.CommandType.StoredProcedure;
        foreach (var p in plan.Parameters)
        {
            var prm = cmd.CreateParameter();
            prm.ParameterName = p.Name;
            prm.DbType = p.DbType;
            if (p.Size is int s && s > 0) prm.Size = s;
            prm.Direction = p.IsOutput ? System.Data.ParameterDirection.InputOutput : System.Data.ParameterDirection.Input;
            prm.Value = DBNull.Value;
            cmd.Parameters.Add(prm);
        }

        var interceptors = await InvokeBeforeAsync(interceptorProvider, plan.Name, cmd, input, ct).ConfigureAwait(false);
        var start = DateTime.UtcNow;

        try
        {
            if (connection.State != ConnectionState.Open)
            {
                await connection.OpenAsync(ct).ConfigureAwait(false);
            }

            plan.Binder(cmd, input);

            await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);

            for (int i = 0; i < plan.ResultSets.Length; i++)
            {
                if (i == resultSetIndex)
                {
                    await streamAction(reader, ct).ConfigureAwait(false);
                }
                else
                {
                    while (await reader.ReadAsync(ct).ConfigureAwait(false))
                    {
                        // Discard rows for non-target result sets.
                    }
                }

                if (i < plan.ResultSets.Length - 1)
                {
                    if (!await reader.NextResultAsync(ct).ConfigureAwait(false))
                    {
                        break;
                    }
                }
            }

            var outputs = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
            foreach (DbParameter dbp in cmd.Parameters)
            {
                if (dbp.Direction.HasFlag(System.Data.ParameterDirection.Output) || dbp.Direction.HasFlag(System.Data.ParameterDirection.InputOutput))
                {
                    var key = dbp.ParameterName.TrimStart('@');
                    outputs[key] = dbp.Value == DBNull.Value ? null : dbp.Value;
                }
            }

            var outputObj = plan.OutputFactory(outputs);
            var duration = DateTime.UtcNow - start;
            await NotifyAfterAsync(interceptors, plan.Name, cmd, true, null, duration, outputObj, ct).ConfigureAwait(false);
            return outputObj;
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - start;
            try
            {
                await NotifyAfterAsync(interceptors, plan.Name, cmd, false, ex.Message, duration, null, ct).ConfigureAwait(false);
            }
            catch
            {
                // Intentionally ignore interceptor failures while propagating the exception.
            }

            throw;
        }
    }

    private static async Task<List<(IXtraqProcedureInterceptor Interceptor, object? State)>?> InvokeBeforeAsync(
        IXtraqProcedureInterceptorProvider? interceptorProvider,
        string procedureName,
        DbCommand command,
        object? state,
        CancellationToken cancellationToken)
    {
        var interceptors = CollectInterceptors(interceptorProvider);
        if (interceptors.Count == 0)
        {
            return null;
        }

        var results = new List<(IXtraqProcedureInterceptor, object?)>(interceptors.Count);
        foreach (var interceptor in interceptors)
        {
            object? beforeState = null;
            try
            {
                beforeState = await interceptor.OnBeforeExecuteAsync(procedureName, command, state, cancellationToken).ConfigureAwait(false);
            }
            catch
            {
                // Ignore interceptor failures in the before hook.
            }

            results.Add((interceptor, beforeState));
        }

        return results;
    }

    private static async Task NotifyAfterAsync(
        List<(IXtraqProcedureInterceptor Interceptor, object? State)>? interceptors,
        string procedureName,
        DbCommand command,
        bool success,
        string? error,
        TimeSpan duration,
        object? aggregate,
        CancellationToken cancellationToken)
    {
        if (interceptors is null || interceptors.Count == 0)
        {
            return;
        }

        foreach (var (interceptor, beforeState) in interceptors)
        {
            try
            {
                await interceptor.OnAfterExecuteAsync(procedureName, command, success, error, duration, beforeState, aggregate, cancellationToken).ConfigureAwait(false);
            }
            catch
            {
                // Ignore individual interceptor failures in the after hook.
            }
        }
    }

    private static List<IXtraqProcedureInterceptor> CollectInterceptors(IXtraqProcedureInterceptorProvider? interceptorProvider)
    {
        if (interceptorProvider is null)
        {
            return new List<IXtraqProcedureInterceptor>();
        }

        try
        {
            var interceptors = interceptorProvider.GetInterceptors();
            if (interceptors == null || interceptors.Count == 0)
            {
                return new List<IXtraqProcedureInterceptor>();
            }

            var collected = new List<IXtraqProcedureInterceptor>(interceptors.Count);
            for (int i = 0; i < interceptors.Count; i++)
            {
                var interceptor = interceptors[i];
                if (interceptor != null)
                {
                    collected.Add(interceptor);
                }
            }

            return collected;
        }
        catch
        {
            return new List<IXtraqProcedureInterceptor>();
        }
    }
}

internal static class TvpHelper
{
    // Converts a single record or enumerable of records into SqlDataRecord collection for TVP binding.
    public static IEnumerable<SqlDataRecord>? BuildRecords(object? value)
    {
        if (value == null) return null;
        var list = value as System.Collections.IEnumerable;
        if (list == null)
        {
            // wrap single instance
            list = new object[] { value };
        }
        var enumerator = list.GetEnumerator();
        // Peek first element to build metadata
        if (!enumerator.MoveNext()) return null; // empty -> null
        var first = enumerator.Current;
        if (first == null) return null;
        var rowType = first.GetType();
        var properties = rowType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        var meta = new List<SqlMetaData>();
        foreach (var p in properties)
        {
            var sqlType = MapClrToSqlDbType(p.PropertyType);
            if (sqlType == SqlDbType.NVarChar || sqlType == SqlDbType.VarBinary)
            {
                // No length metadata available -> use Max for simplicity
                meta.Add(new SqlMetaData(p.Name, sqlType, SqlMetaData.Max));
            }
            else if (sqlType == SqlDbType.Decimal)
            {
                meta.Add(new SqlMetaData(p.Name, sqlType, 18, 4));
            }
            else
            {
                meta.Add(new SqlMetaData(p.Name, sqlType));
            }
        }
        var records = new List<SqlDataRecord>();
        // Add first row
        var firstRecord = new SqlDataRecord(meta.ToArray());
        var firstValues = properties.Select(pr => pr.GetValue(first) ?? DBNull.Value).ToArray();
        firstRecord.SetValues(firstValues);
        records.Add(firstRecord);
        // Remaining rows
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (current == null) continue;
            var rec = new SqlDataRecord(meta.ToArray());
            var values = properties.Select(pr => pr.GetValue(current) ?? DBNull.Value).ToArray();
            rec.SetValues(values);
            records.Add(rec);
        }
        return records.Count > 0 ? records : null;
    }

    private static SqlDbType MapClrToSqlDbType(Type t)
    {
        t = Nullable.GetUnderlyingType(t) ?? t;
        if (t == typeof(int)) return SqlDbType.Int;
        if (t == typeof(long)) return SqlDbType.BigInt;
        if (t == typeof(short)) return SqlDbType.SmallInt;
        if (t == typeof(byte)) return SqlDbType.TinyInt;
        if (t == typeof(bool)) return SqlDbType.Bit;
        if (t == typeof(decimal)) return SqlDbType.Decimal;
        if (t == typeof(double)) return SqlDbType.Float;
        if (t == typeof(float)) return SqlDbType.Real;
        if (t == typeof(DateTime)) return SqlDbType.DateTime2;
        if (t == typeof(Guid)) return SqlDbType.UniqueIdentifier;
        if (t == typeof(byte[])) return SqlDbType.VarBinary;
        // default string
        return SqlDbType.NVarChar;
    }
}

internal static class ReaderUtil
{
    private static readonly bool Verbose = string.Equals(Environment.GetEnvironmentVariable("XTRAQ_VERBOSE"), "1", StringComparison.Ordinal);
    public static int TryGetOrdinal(DbDataReader reader, string name)
    {
        // Exact match first
        for (int i = 0; i < reader.FieldCount; i++)
        {
            if (reader.GetName(i).Equals(name, StringComparison.Ordinal)) return i;
        }
        // Case-insensitive fallback
        for (int i = 0; i < reader.FieldCount; i++)
        {
            if (reader.GetName(i).Equals(name, StringComparison.OrdinalIgnoreCase)) return i;
        }
        // Loose normalization (remove underscores, to lowercase)
        var normalized = new string(name.Where(ch => ch != '_').ToArray()).ToLowerInvariant();
        for (int i = 0; i < reader.FieldCount; i++)
        {
            var candidate = new string(reader.GetName(i).Where(ch => ch != '_').ToArray()).ToLowerInvariant();
            if (candidate == normalized) return i;
        }
        return -1; // Not found
    }

    public static void DumpColumns(DbDataReader reader)
    {
        try
        {
            if (!Verbose) return;
            var cols = new System.Collections.Generic.List<string>();
            for (int i = 0; i < reader.FieldCount; i++)
            {
                cols.Add(reader.GetName(i));
            }
            System.Console.Out.WriteLine("[xtraq] Debug: Columns=" + string.Join(",", cols));
        }
        catch { }
    }

    public static void DumpFirstRow(DbDataReader reader)
    {
        try
        {
            if (!Verbose) return;
            if (!reader.HasRows) { System.Console.Out.WriteLine("[xtraq] Debug: No rows."); return; }
            // Peek without consuming row set permanently -> we cannot easily reset, so only call before main loop
            if (!reader.Read()) { System.Console.Out.WriteLine("[xtraq] Debug: Read failed."); return; }
            var pairs = new System.Collections.Generic.List<string>();
            for (int i = 0; i < reader.FieldCount; i++)
            {
                var val = reader.IsDBNull(i) ? "<NULL>" : Convert.ToString(reader.GetValue(i)) ?? "";
                pairs.Add(reader.GetName(i) + "=" + val);
            }
            System.Console.Out.WriteLine("[xtraq] Debug: FirstRow=" + string.Join(";", pairs));
        }
        catch { }
    }
}
