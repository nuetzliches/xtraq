---
title: Minimal APIs & DTO Mapping
description: Wire generated Xtraq procedures into ASP.NET Core Minimal APIs and translate the typed results into domain DTOs without leaking SQL-specific details.
---

## Putting Generated Procedures Behind a Minimal API

The project template in `samples/restapi/Program.cs` demonstrates how any generated procedure—JSON-enabled or purely tabular—plugs into a Minimal API endpoint. Resolve the connection string once, register the generated `IXtraqDbContext`, call the typed helper (for example `FileFindAsJsonAsync` or `InvoiceListAsync`), and pass the projection straight to the client or a mapper.

```csharp
using Microsoft.AspNetCore.Http.HttpResults;
using SampleApp.Xtraq;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddXtraqDbContext(options =>
{
  options.ConnectionString = builder.Configuration.GetConnectionString("DefaultConnection")
    ?? throw new InvalidOperationException("Configure the 'DefaultConnection' connection string in appsettings.json");
});

var app = builder.Build();

app.MapGet("/files/{fileId:int}", async Task<Results<Ok<FileSummary>, NotFound>> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
{
  var row = (await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false)).Result;
  return row is null
    ? TypedResults.NotFound()
    : TypedResults.Ok(FileMappings.Expand(row));
});

app.Run();
```

- Swap in whichever generated helper matches your stored procedure (tabular or JSON).
- Need to flow an EF Core transaction? See [Entity Framework Integration](./6.entity-framework-integration.md).

### Fluent Pipeline Endpoint Helpers

Enable the Minimal API toggle before running `xtraq build` so the generator emits `ProcedureRouteHandlerBuilderExtensions` (guarded by `#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API`).

```json
// .xtraqconfig (excerpt)
{
  "Namespace": "SampleApp.Xtraq",
  "MinimalApi": true
}
```

```xml
<!-- Add to the ASP.NET Core project -->
<PropertyGroup>
  <DefineConstants>$(DefineConstants);XTRAQ_MINIMAL_API</DefineConstants>
</PropertyGroup>
```

Once enabled, attach a fluent pipeline directly to any `MapGet`/`MapPost`. The extension inspects the route delegate signature (input record + optional `CancellationToken`), resolves `IXtraqDbContext`, and executes the configured pipeline before the delegate body would run.

```csharp
app.MapPost("/orders", (OrderCreateInput input, CancellationToken ct) => Results.Empty)
   .WithProcedure<OrderCreateInput, OrderCreateResult>(
       pipeline => pipeline
           .WithTransaction()
           .WithExecutor((db, payload, token) => db.OrderCreateAsync(payload, token))
           .Select(result => result.Result));
```

Key points:

- The delegate still declares the parameters you want to bind; its body is skipped after the pipeline produces a result.
- Delegates that already return `IResult` flow through unchanged; otherwise the extension wraps the projection in `Results.Ok`.
- Policies (`WithPolicy`, `WithTransaction`, labels, etc.) are the same ones you use outside ASP.NET Core—the filter simply builds a pipeline per request.

#### Generated route scaffolding

`ProcedureBuilders.cs` also emits `ProcedureRouteHandlerScaffolding`: a `With<Schema><Procedure>Procedure` helper per stored procedure so endpoints can opt in without touching generics.

```csharp
app.MapPost("/orders", () => Results.Empty)
  .WithSalesOrderCreateProcedure();
```

- Each helper wires the proper input/result types into `.WithProcedure<TInput, TResult>`.
- Method names include the schema prefix (`dbo` => `Dbo`) to stay unique.
- Extend the scaffolding via partial classes (for example append `.WithTransaction()`) without diverging from generator output.

#### Streaming helpers and NDJSON output

Use `WithProcedureStream` when you want an endpoint to stream rows as they are produced. The extension reuses the fluent streaming pipeline and exposes two customisation points: the pipeline configuration and an optional response writer that receives the row stream (`IAsyncEnumerable<TRow>`) plus the pipeline completion task (for output parameters or aggregates).

```csharp
app.MapGet("/orders/stream", (OrderListInput input, CancellationToken ct) => Results.Empty)
   .WithProcedureStream<OrderListInput, OrderListResultSet1Row, OrderListResult, OrderListResult>(
     pipeline => pipeline
       .WithExecutor((db, payload, onRow, token) => db.OrderList.StreamResultResultSet1Async(payload, onRow, token)));
```

- The default response writer emits newline-delimited JSON (`application/x-ndjson`) and flushes after each row. No buffering is required and the route delegate body is skipped once the pipeline runs.
- Pass a custom `responseWriter` when you need to return typed results (for example gRPC streaming or `TypedResults.Stream`) or access the pipeline completion task to surface output parameters alongside the stream.
- Existing per-row handlers chained via `ForEach` and `TapCompletion` remain in place—the Minimal API filter simply appends its writer and leaves your instrumentation policies intact.

## Streaming Result Sets Without Buffering

Generated procedures expose paired `StreamResult…Async` helpers when a result set supports forward-only streaming. These helpers execute the stored procedure, position the reader on the selected result set, and push each row into a user-supplied callback without materialising the aggregate payload.

```csharp
app.MapGet("/users/stream", async Task StreamUsers(HttpResponse response, IXtraqDbContext db, CancellationToken ct) =>
{
  response.StatusCode = StatusCodes.Status200OK;
  response.ContentType = "application/x-ndjson"; // newline-delimited JSON
  response.Headers.CacheControl = "no-store";

  await using var writer = new StreamWriter(response.Body, leaveOpen: true);
  var jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);

  await db.UserList.StreamResultResultSet1Async(
    new UserListInput(includeInactive: false),
    async (row, token) =>
    {
      var payload = JsonSerializer.Serialize(row, jsonOptions);
      await writer.WriteLineAsync(payload.AsMemory(), token).ConfigureAwait(false);
      await writer.FlushAsync(token).ConfigureAwait(false);
    },
    ct).ConfigureAwait(false);
});
```

Key points:

- The generator keeps the callback signature as `Func<TRow, CancellationToken, ValueTask>` so async pipelines (writing to HTTP, channels, gRPC streams) remain allocation-friendly.
- Output parameters, when present, are returned by the streaming helper. Capture them via `var output = await db.Proc.StreamResult…Async(...)` before writing the HTTP response headers.
- You can combine streaming with Domain DTOs by projecting inside the callback or forwarding rows into a dedicated mapper class.

## Example: Rehydrating Results into a Domain DTO

Endpoints stay orchestration-focused when DTO mapping and enrichment live beside the generated extensions. The mapper below translates the generated record (`FileFindAsJsonResultSet1Result`) into a domain-level summary and, on demand, streams file content into a Base64 payload—illustrating the same technique you would use for non-JSON result sets.

```csharp
internal static class FileMappings
{
  public static FileSummary Expand(FileFindAsJsonResultSet1Result row) => new(
    row.fileId,
    row.fileName,
    Normalize(row.contentType),
    row.size,
    Normalize(row.hash));

  public static async Task<FileSummary> ExpandWithContentAsync(this FileSummary summary, string contentPath, CancellationToken ct)
  {
    var bytes = await File.ReadAllBytesAsync(contentPath, ct).ConfigureAwait(false);
    return summary with { Base64Content = Convert.ToBase64String(bytes) };
  }

  private static string? Normalize(string? value) => string.IsNullOrWhiteSpace(value) ? null : value;
}

internal sealed record FileSummary(int FileId, string FileName, string? ContentType, long Size, string? Hash)
{
  public string? Base64Content { get; init; }
}
```

## Fluent Procedure Pipeline

Generated projects ship an opt-in helper (`ProcedurePipelineExtensions`) that layers configuration primitives over the typed `IXtraqDbContext` surface without touching the artefacts themselves. The workflow splits into two stages:

- `ConfigureProcedure` / `WithExecutor` build a `ProcedureCallPipeline` that can be labelled, decorated with `IProcedureExecutionPolicy` instances, and then materialised via `ProcedureCallExecution` for `Select`, `SelectAsync`, `Tap`, and `TapAsync` composition.
- `ConfigureProcedureStream` / `WithExecutor` produce a `ProcedureStreamExecution` that reuses the same policy pipeline while adding streaming helpers (`ForEach`, `TapCompletion`, `BufferAsync`, `AggregateAsync`).

```csharp
var execution = db.ConfigureProcedure(new UserFindInput(userId))
  .WithLabel("users.find")
  .WithPolicies(new IProcedureExecutionPolicy[] { new SampleRetryPolicy(), new SampleCircuitBreakerPolicy() })
  .WithExecutor(static (ctx, input, ct) => ctx.UserFindAsync(input, ct));

var favouriteContacts = await execution
  .Select(result => result.Result
    .Where(r => string.Equals(r.PreferredLocale, "en-US", StringComparison.OrdinalIgnoreCase))
    .ToArray())
  .ExecuteAsync(ct);

var streamed = await db.ConfigureProcedureStream<UserListInput, UserListResultSet1Row>(
    new UserListInput(includeInactive: false))
  .WithLabel("users.stream")
  .WithPolicy(new SampleRetryPolicy())
  .WithExecutor(static (ctx, input, onRow, ct) => ctx.UserList.StreamResultResultSet1Async(input, onRow, ct))
  .AggregateAsync((rows, output) => new
  {
    Count = rows.Count,
    Output = output
  },
  ct);
```

### Pipeline Guidelines

1. **Keep generated partials untouched.** Pipelines live beside the artefacts and never edit the generated classes.
2. **Flow DI across boundaries.** Instantiate the pipeline within the scope that owns `IXtraqDbContext` so the connection lifetime mirrors existing patterns.
3. **Lean on policies.** Implement retry, timeout, and telemetry concerns via `IProcedureExecutionPolicy` instead of layering ad-hoc delegates inside the execution chain.
4. **Prefer streaming when available.** `ProcedureStreamExecution` composes row handlers, exposes completion taps, and offers `BufferAsync`/`AggregateAsync` helpers for when materialisation is unavoidable.
5. **Document intent.** Wrap pipeline-based workflows in extension methods with XML summaries so downstream teams know the fluent surface is opt-in.

The helper keeps the generator deterministic while unlocking richer composition for teams that prefer fluent orchestration, centralised instrumentation, or middleware-friendly streaming without redundant buffering.

Guidelines when exposing generated procedures via HTTP endpoints:

- Always read from the typed projection (`Result`, `ResultSets`, or strongly typed record) and reserve raw JSON helpers for diagnostics.
- Keep endpoints orchestration-focused. Mapping and enrichment belong in dedicated helpers like `FileMappings` or partial classes layered over the generated code.
- Compute expensive enrichments (for example file IO) via helpers such as `ExpandWithContentAsync` that accept the resolved storage path instead of embedding file-system logic inside the endpoint.
- Prefer records and `with` expressions to extend immutable summaries instead of mutating generated types.
- Normalise nullable strings early so downstream formatters do not emit empty values that could break clients.
- Promote consistent problem responses—wrapping `SqlException` into RFC 7807 payloads keeps infrastructure failures observable without leaking raw SQL errors.

These practices keep API controllers thin, preserve deterministic generator output, and make downstream contracts explicit—regardless of whether the procedure emits JSON payloads or tabular result sets.
