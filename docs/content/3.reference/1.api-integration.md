---
title: Minimal APIs & DTO Mapping
description: Wire generated Xtraq procedures into ASP.NET Core Minimal APIs and translate the typed results into domain DTOs without leaking SQL-specific details.
---

## Putting Generated Procedures Behind a Minimal API

The project template in `samples/restapi/Program.cs` demonstrates how any generated procedure—JSON-enabled or purely tabular—plugs into a Minimal API endpoint. Resolve the connection string once, register the generated `IXtraqDbContext`, call the typed helper (for example `FileFindAsJsonAsync` or `InvoiceListAsync`), and pass the projection straight to the client or a mapper.

::tabs{.w-full}
  :::tabs-item{label="Minimal API (net8.0)"}

    ```csharp
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq; // namespace emitted by xtraq build

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseHttpsRedirection();

    app.MapGet("/files/{fileId:int}", async Task<IResult> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return Results.NotFound(new { error = $"File {fileId} was not found." });
        }

        var dto = FileMappings.ToSummary(row);
        return Results.Ok(dto);
      }
      catch (SqlException ex)
      {
        return Results.Problem("Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: SqlProblemPayload.From(ex));
      }
    });

    app.Run();
    ```

  :::
  :::tabs-item{label="Minimal API (net10.0)"}

    ```csharp
    using Microsoft.AspNetCore.Http.HttpResults;
    using Microsoft.Data.SqlClient;
    using SampleApp.Xtraq;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddProblemDetails();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddXtraqDbContext(options =>
    {
      options.ConnectionString = builder.Configuration.GetConnectionString("SampleDb")
        ?? throw new InvalidOperationException("Configure the 'SampleDb' connection string in appsettings.json.");
      options.CommandTimeout = 30;
    });

    var app = builder.Build();
    app.UseExceptionHandler();
    app.UseHttpsRedirection();

    var files = app.MapGroup("/files").WithTags("Files");

    files.MapGet("/{fileId:int}", async Task<Results<Ok<FileSummary>, NotFound, ProblemHttpResult>> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
    {
      try
      {
        var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
        if (response.Result is not { } row)
        {
          return TypedResults.NotFound();
        }

        var dto = FileMappings.ToSummary(row);
        return TypedResults.Ok(dto);
      }
      catch (SqlException ex)
      {
        var problem = SqlProblemPayload.From(ex);
        return TypedResults.Problem(title: "Database unavailable", statusCode: StatusCodes.Status503ServiceUnavailable, extensions: problem);
      }
    });

    app.Run();
    ```

  :::
::

> The procedure used in the snippet returns JSON, but the pattern is identical for tabular result sets. Swap in the generated helper that matches your stored procedure.

## Example: Rehydrating Results into a Domain DTO

Endpoints stay orchestration-focused when DTO mapping and enrichment live beside the generated extensions. The mapper below translates the generated record (`FileFindAsJsonResultSet1Result`) into a domain-level summary and, on demand, streams file content into a Base64 payload—illustrating the same technique you would use for non-JSON result sets.

```csharp
internal static class FileMappings
{
  public static FileSummary ToSummary(FileFindAsJsonResultSet1Result row) => new(
    row.fileId,
    row.fileName,
    Normalize(row.contentType),
    row.size,
    Normalize(row.hash));

  public static async Task<FileSummary> WithContentAsync(this FileSummary summary, string contentPath, CancellationToken ct)
  {
    var bytes = await File.ReadAllBytesAsync(contentPath, ct).ConfigureAwait(false);
    return summary with { Base64Content = Convert.ToBase64String(bytes) };
  }

  private static string? Normalize(string? value) => string.IsNullOrWhiteSpace(value) ? null : value;
}

internal sealed record FileSummary(int FileId, string FileName, string? ContentType, long Size, string? Hash)
{
  public string? Base64Content { get; init; }
}

internal static class SqlProblemPayload
{
  public static IDictionary<string, object?> From(SqlException exception) =>
    new Dictionary<string, object?>
    {
      ["sqlNumber"] = exception.Number,
      ["sqlState"] = exception.State,
      ["server"] = exception.Server,
      ["procedure"] = exception.Procedure,
      ["lineNumber"] = exception.LineNumber
    };
}
```

`ToSummary` keeps the default response lightweight, while `WithContentAsync` eagerly loads the file stream, base64-encodes it, and returns a new immutable record for download scenarios.

> Tip: Resolve storage paths in the application layer (for example `Path.Combine(storageRoot, row.directoryRef, row.fileName)`) and call `await summary.WithContentAsync(path, ct)` only when a request explicitly needs the payload. This keeps the default response lightweight while leaving an escape hatch for downloads.

Guidelines when exposing generated procedures via HTTP endpoints:

- Always read from the typed projection (`Result`, `ResultSets`, or strongly typed record) and reserve raw JSON helpers for diagnostics.
- Keep endpoints orchestration-focused. Mapping and enrichment belong in dedicated helpers like `FileMappings` or partial classes layered over the generated code.
- Compute expensive enrichments (for example file IO) via helpers such as `WithContentAsync` that accept the resolved storage path instead of embedding file-system logic inside the endpoint.
- Prefer records and `with` expressions to extend immutable summaries instead of mutating generated types.
- Normalise nullable strings early so downstream formatters do not emit empty values that could break clients.
- Promote consistent problem responses—wrapping `SqlException` into RFC 7807 payloads keeps infrastructure failures observable without leaking raw SQL errors.

These practices keep API controllers thin, preserve deterministic generator output, and make downstream contracts explicit—regardless of whether the procedure emits JSON payloads or tabular result sets.
