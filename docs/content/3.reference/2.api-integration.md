---
title: Minimal APIs & DTO Mapping
description: Wire generated Xtraq procedures into ASP.NET Core Minimal APIs and translate the typed results into domain DTOs without leaking SQL-specific details.
---

## Putting Generated Procedures Behind a Minimal API

The project template in `samples/restapi/Program.cs` demonstrates how any generated procedure—JSON-enabled or purely tabular—plugs into a Minimal API endpoint. Resolve the connection string once, register the generated `IXtraqDbContext`, call the typed helper (for example `FileFindAsJsonAsync` or `InvoiceListAsync`), and pass the projection straight to the client or a mapper.

```csharp
using Microsoft.AspNetCore.Http.HttpResults;
using SampleApp.Xtraq;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddXtraqDbContext(options =>
{
  options.ConnectionString = builder.Configuration.GetConnectionString("DefaultConnection")
    ?? throw new InvalidOperationException("Configure the 'DefaultConnection' connection string in appsettings.json");
});

var app = builder.Build();

app.MapGroup("/files")
   .WithTags("Files")
   .MapGet("/{fileId:int}", async Task<Results<Ok<FileSummary>, NotFound>> (int fileId, IXtraqDbContext db, CancellationToken ct) =>
{
  var response = await db.FileFindAsJsonAsync(new FileFindInput(fileId), ct).ConfigureAwait(false);
  if (response.Result is not { } row)
  {
    return TypedResults.NotFound();
  }

  var dto = FileMappings.Expand(row);
  return TypedResults.Ok(dto);
});

app.Run();
```

- The procedure used in the snippet returns JSON, but the pattern is identical for tabular result sets—swap in the generated helper that matches your stored procedure.
- To reuse an Entity Framework Core transaction, see [Entity Framework Integration](./6.entity-framework-integration.md) for the ambient bridge and registration steps.

### Fluent Pipeline Endpoint Helpers

When you prefer to keep endpoint wiring declarative, enable the Minimal API toggle before running `xtraq build` so the generator emits `ProcedureRouteHandlerBuilderExtensions`. The file lives behind `#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API`, so non-web hosts remain unaffected by default.

```json
// .xtraqconfig (excerpt)
{
  "Namespace": "SampleApp.Xtraq",
  "MinimalApi": true
}
```

After regenerating artifacts, define the compilation symbol in the ASP.NET Core project so the extension compiles:

```xml
<!-- Sample csproj snippet -->
<PropertyGroup>
  <DefineConstants>$(DefineConstants);XTRAQ_MINIMAL_API</DefineConstants>
</PropertyGroup>
```

With the toggle active you can compose the fluent pipeline and attach it to a standard `MapGet`/`MapPost` definition. The extension inspects the route handler arguments to locate the generated input record and optional `CancellationToken`, resolves `IXtraqDbContext` from DI, and executes the configured pipeline before the delegate body runs.

```csharp
app.MapPost("/orders", (OrderCreateInput input, CancellationToken ct) => Results.Empty)
   .WithProcedure<OrderCreateInput, OrderCreateResult>(
       pipeline => pipeline
           .WithTransaction()
           .WithExecutor((db, payload, token) => db.OrderCreateAsync(payload, token))
           .Select(result => result.Result));
```

Key points:

- The original route delegate still defines the parameters you want to bind (for example route values, body DTOs, or `CancellationToken`), but its body is bypassed once the pipeline succeeds.
- Pipelines that already return an `IResult` flow through unchanged; otherwise the extension forwards the projected value using `Results.Ok` by default.
- Dependency policies (`WithPolicy`, `WithTransaction`, labels, etc.) compose exactly as they do in non-web hosts because the route filter materialises a fresh `ProcedureCallPipeline` per request.

#### Generated route scaffolding

`ProcedureBuilders.cs` now emits a `ProcedureRouteHandlerScaffolding` helper beside the fluent extensions. Every stored procedure receives a strongly typed method named `With<Schema><Procedure>Procedure`, so Minimal API endpoints can opt in with a single call and stay aligned with the generated surface:

```csharp
app.MapPost("/orders", () => Results.Empty)
  .WithSalesOrderCreateProcedure();
```

- The method wires in the generated input/result types and calls the matching `.WithProcedure<TInput, TResult>` overload.
- Naming follows the Pascal-cased schema prefix (`dbo` becomes `Dbo`) to keep method identifiers unique when multiple schemas expose similarly named procedures.
- Treat the scaffolding as a starting point—add `.WithTransaction()` or `.Select(...)` via partial classes if a route needs calibration while keeping the generator output deterministic.

#### Streaming helpers and NDJSON output

Use `WithProcedureStream` when you want an endpoint to stream rows as they are produced. The extension reuses the fluent streaming pipeline and exposes two customisation points: the pipeline configuration and an optional response writer that receives the row stream (`IAsyncEnumerable<TRow>`) plus the pipeline completion task (for output parameters or aggregates).

```csharp
app.MapGet("/orders/stream", (OrderListInput input, CancellationToken ct) => Results.Empty)
   .WithProcedureStream<OrderListInput, OrderListResultSet1Row, OrderListResult, OrderListResult>(
     pipeline => pipeline
       .WithExecutor((db, payload, onRow, token) => db.OrderList.StreamResultResultSet1Async(payload, onRow, token)));
```

- The default response writer emits newline-delimited JSON (`application/x-ndjson`) and flushes after each row. No buffering is required and the route delegate body is skipped once the pipeline runs.
- Pass a custom `responseWriter` when you need to return typed results (for example gRPC streaming or `TypedResults.Stream`) or access the pipeline completion task to surface output parameters alongside the stream.
- Existing per-row handlers chained via `ForEach` and `TapCompletion` remain in place—the Minimal API filter simply appends its writer and leaves your instrumentation policies intact.

## Streaming Result Sets Without Buffering

Generated procedures expose paired `StreamResult…Async` helpers when a result set supports forward-only streaming. These helpers execute the stored procedure, position the reader on the selected result set, and push each row into a user-supplied callback without materialising the aggregate payload.

```csharp
app.MapGet("/users/stream", async Task StreamUsers(HttpResponse response, IXtraqDbContext db, CancellationToken ct) =>
{
  response.StatusCode = StatusCodes.Status200OK;
  response.ContentType = "application/x-ndjson"; // newline-delimited JSON
  response.Headers.CacheControl = "no-store";

  await using var writer = new StreamWriter(response.Body, leaveOpen: true);
  var jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);

  await db.UserList.StreamResultResultSet1Async(
    new UserListInput(includeInactive: false),
    async (row, token) =>
    {
      var payload = JsonSerializer.Serialize(row, jsonOptions);
      await writer.WriteLineAsync(payload.AsMemory(), token).ConfigureAwait(false);
      await writer.FlushAsync(token).ConfigureAwait(false);
    },
    ct).ConfigureAwait(false);
});
```

Key points:

- The generator keeps the callback signature as `Func<TRow, CancellationToken, ValueTask>` so async pipelines (writing to HTTP, channels, gRPC streams) remain allocation-friendly.
- Output parameters, when present, are returned by the streaming helper. Capture them via `var output = await db.Proc.StreamResult…Async(...)` before writing the HTTP response headers.
- You can combine streaming with Domain DTOs by projecting inside the callback or forwarding rows into a dedicated mapper class.

## Example: Rehydrating Results into a Domain DTO

Endpoints stay orchestration-focused when DTO mapping and enrichment live beside the generated extensions. The mapper below translates the generated record (`FileFindAsJsonResultSet1Result`) into a domain-level summary and, on demand, streams file content into a Base64 payload—illustrating the same technique you would use for non-JSON result sets.

```csharp
internal static class FileMappings
{
  public static FileSummary Expand(FileFindAsJsonResultSet1Result row) => new(
    row.fileId,
    row.fileName,
    Normalize(row.contentType),
    row.size,
    Normalize(row.hash));

  public static async Task<FileSummary> ExpandWithContentAsync(this FileSummary summary, string contentPath, CancellationToken ct)
  {
    var bytes = await File.ReadAllBytesAsync(contentPath, ct).ConfigureAwait(false);
    return summary with { Base64Content = Convert.ToBase64String(bytes) };
  }

  private static string? Normalize(string? value) => string.IsNullOrWhiteSpace(value) ? null : value;
}

internal sealed record FileSummary(int FileId, string FileName, string? ContentType, long Size, string? Hash)
{
  public string? Base64Content { get; init; }
}
```

## Fluent Procedure Pipeline

Generated projects ship an opt-in helper (`ProcedurePipelineExtensions`) that layers configuration primitives over the typed `IXtraqDbContext` surface without touching the artefacts themselves. The workflow splits into two stages:

- `ConfigureProcedure` / `WithExecutor` build a `ProcedureCallPipeline` that can be labelled, decorated with `IProcedureExecutionPolicy` instances, and then materialised via `ProcedureCallExecution` for `Select`, `SelectAsync`, `Tap`, and `TapAsync` composition.
- `ConfigureProcedureStream` / `WithExecutor` produce a `ProcedureStreamExecution` that reuses the same policy pipeline while adding streaming helpers (`ForEach`, `TapCompletion`, `BufferAsync`, `AggregateAsync`).

```csharp
var execution = db.ConfigureProcedure(new UserFindInput(userId))
  .WithLabel("users.find")
  .WithPolicies(new IProcedureExecutionPolicy[] { new SampleRetryPolicy(), new SampleCircuitBreakerPolicy() })
  .WithExecutor(static (ctx, input, ct) => ctx.UserFindAsync(input, ct));

var favouriteContacts = await execution
  .Select(result => result.Result
    .Where(r => string.Equals(r.PreferredLocale, "en-US", StringComparison.OrdinalIgnoreCase))
    .ToArray())
  .ExecuteAsync(ct);

var streamed = await db.ConfigureProcedureStream<UserListInput, UserListResultSet1Row>(
    new UserListInput(includeInactive: false))
  .WithLabel("users.stream")
  .WithPolicy(new SampleRetryPolicy())
  .WithExecutor(static (ctx, input, onRow, ct) => ctx.UserList.StreamResultResultSet1Async(input, onRow, ct))
  .AggregateAsync((rows, output) => new
  {
    Count = rows.Count,
    Output = output
  },
  ct);
```

### Pipeline Guidelines

1. **Keep generated partials untouched.** Pipelines live beside the artefacts and never edit the generated classes.
2. **Flow DI across boundaries.** Instantiate the pipeline within the scope that owns `IXtraqDbContext` so the connection lifetime mirrors existing patterns.
3. **Lean on policies.** Implement retry, timeout, and telemetry concerns via `IProcedureExecutionPolicy` instead of layering ad-hoc delegates inside the execution chain.
4. **Prefer streaming when available.** `ProcedureStreamExecution` composes row handlers, exposes completion taps, and offers `BufferAsync`/`AggregateAsync` helpers for when materialisation is unavoidable.
5. **Document intent.** Wrap pipeline-based workflows in extension methods with XML summaries so downstream teams know the fluent surface is opt-in.

The helper keeps the generator deterministic while unlocking richer composition for teams that prefer fluent orchestration, centralised instrumentation, or middleware-friendly streaming without redundant buffering.

Guidelines when exposing generated procedures via HTTP endpoints:

- Always read from the typed projection (`Result`, `ResultSets`, or strongly typed record) and reserve raw JSON helpers for diagnostics.
- Keep endpoints orchestration-focused. Mapping and enrichment belong in dedicated helpers like `FileMappings` or partial classes layered over the generated code.
- Compute expensive enrichments (for example file IO) via helpers such as `ExpandWithContentAsync` that accept the resolved storage path instead of embedding file-system logic inside the endpoint.
- Prefer records and `with` expressions to extend immutable summaries instead of mutating generated types.
- Normalise nullable strings early so downstream formatters do not emit empty values that could break clients.
- Promote consistent problem responses—wrapping `SqlException` into RFC 7807 payloads keeps infrastructure failures observable without leaking raw SQL errors.

These practices keep API controllers thin, preserve deterministic generator output, and make downstream contracts explicit—regardless of whether the procedure emits JSON payloads or tabular result sets.
