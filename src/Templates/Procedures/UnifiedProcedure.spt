{{ HEADER }}
#nullable enable
namespace {{ Namespace }};

{{ UsingDirectives }}

/// <summary>
/// Represents the contract for the stored procedure <c>{{ Schema }}.{{ Name }}</c> including parameters, result sets and execution metadata.
/// </summary>
/// <remarks>
/// Generated by the Xtraq CLI. To change this artifact, modify the underlying SQL stored procedure definition.
/// </remarks>
{{#if HasInput}}
public readonly record struct {{ InputTypeName }}(
{{#each InputParameters as parameter}}    {{ parameter.ClrType }} {{ parameter.PropertyName }}{{ parameter.Comma }}
{{/each}});

{{/if}}
{{#if HasOutput}}
/// <summary>
/// Captures OUTPUT parameter values returned by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
public readonly record struct {{ OutputTypeName }}(
{{#each OutputFields as field}}    {{ field.ClrType }} {{ field.PropertyName }}{{ field.Comma }}
{{/each}});

{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
/// <summary>
/// Represents the result set <c>{{ resultSet.Name }}</c> emitted by <c>{{ Schema }}.{{ Name }}</c>.
/// </summary>
{{ resultSet.NestedRecordsBlock }}public readonly record struct {{ resultSet.TypeName }}(
{{ resultSet.FieldsBlock }}
);

{{/each}}
{{/if}}
public sealed class {{ UnifiedResultTypeName }}
{
	/// <summary>
	/// Indicates whether the procedure executed without raising an error.
	/// </summary>
	public bool Success { get; init; }
	/// <summary>
	/// Contains the error message when <see cref="Success"/> is <c>false</c>; otherwise <c>null</c>.
	/// </summary>
	public string? Error { get; init; }
{{#if HasOutput}}
	/// <summary>
	/// OUTPUT parameter payload returned by the procedure.
	/// </summary>
	public {{ OutputTypeName }}? Output { get; init; }
{{/if}}
{{#if HasResultSets}}
{{#each ResultSets as resultSet}}
	/// <summary>
	/// Result set <c>{{ resultSet.Name }}</c> projected as a strongly typed sequence.
	/// </summary>
	public {{ resultSet.PropType }} {{ resultSet.PropName }} { get; init; } = {{ resultSet.PropDefault }};
{{/each}}
{{/if}}
}

internal static partial class {{ PlanTypeName }}
{
	private static ProcedureExecutionPlan? _cached;
	public static ProcedureExecutionPlan Instance => _cached ??= Create();
	private static ProcedureExecutionPlan Create()
	{
{{#if HasParameters}}
		var parameters = new ProcedureParameter[]
		{
{{#each ParameterLines as parameterLine}}            {{ parameterLine }},
{{/each}}        };
{{else}}
		var parameters = Array.Empty<ProcedureParameter>();
{{/if}}

{{#if HasResultSets}}
		var resultSets = new ResultSetMapping[]
		{
{{#each ResultSets as resultSet}}            new("{{ resultSet.Name }}", async (r, ct) =>
    	{
			{{ resultSet.BodyBlock }}
    	}),

{{/each}}        };
{{else}}
		var resultSets = Array.Empty<ResultSetMapping>();
{{/if}}

		object? OutputFactory(IReadOnlyDictionary<string, object?> values) => {{#if HasOutput}}new {{ OutputTypeName }}({{ OutputFactoryArgs }}){{else}}null{{/if}};
		object AggregateFactory(bool success, string? error, object? output, IReadOnlyDictionary<string, object?> outputs, object[] rs)
		{
			return new {{ UnifiedResultTypeName }}
			{
				Success = success,
				Error = error{{#if HasOutput}},
				Output = ({{ OutputTypeName }}?)output{{/if}}{{#if HasResultSets}}{{#each ResultSets as resultSet}},
				// ResultSet {{ resultSet.Index }} -> {{ resultSet.PropName }}
				{{ resultSet.PropName }} = {{ resultSet.AggregateAssignment }}{{/each}}{{/if}}
			};
		};
		void Binder(DbCommand cmd, object? state)
		{
{{#if HasInput}}
			var input = ({{ InputTypeName }})state!;
{{#each InputAssignments as assignment}}
			{{ assignment }}
{{/each}}
{{/if}}
		}
		return new ProcedureExecutionPlan(
			"{{ ProcedureFullName }}", parameters, resultSets, OutputFactory, AggregateFactory, Binder);
	}
}

/// <summary>Convenience extension for executing '{{ ProcedureFullName }}' via an <see cref="IXtraqDbContext"/>.</summary>
public static class {{ ProcedureTypeName }}Extensions
{
	public static async Task<{{ UnifiedResultTypeName }}> {{ ProcedureTypeName }}Async(this IXtraqDbContext db{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		await using var conn = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		return await {{ ProcedureTypeName }}Procedure.ExecuteAsync(conn{{#if HasInput}}, input{{/if}}, cancellationToken).ConfigureAwait(false);
	}
}

/// <summary>Low-level execution wrapper for a single stored procedure invocation.</summary>
public static class {{ ProcedureTypeName }}Procedure
{
	public const string Name = "{{ ProcedureFullName }}";
	public static Task<{{ UnifiedResultTypeName }}> ExecuteAsync(DbConnection connection{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		return ProcedureExecutor.ExecuteAsync<{{ UnifiedResultTypeName }}>(connection, {{ PlanTypeName }}.Instance, {{#if HasInput}}input{{else}}null{{/if}}, cancellationToken);
	}
}
