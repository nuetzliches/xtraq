// <auto-generated/>
// Xtraq Code Generator. Do not edit this file directly.
// Changes may be overwritten. For customization extend generated partials.

#nullable enable
namespace Xtraq.Samples.RestApi.Xtraq;

public static class ProcedurePipelineExtensions
{
    public static ProcedureCallPipeline<TInput> ConfigureProcedure<TInput>(
        this IXtraqDbContext dbContext,
        TInput input)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        return ProcedureCallPipeline<TInput>.Create(dbContext, input);
    }

    public static ProcedureCallExecution<TInput, TResult> BuildProcedure<TInput, TResult>(
        this IXtraqDbContext dbContext,
        TInput input,
        Func<IXtraqDbContext, TInput, CancellationToken, ValueTask<TResult>> executor)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        ArgumentNullException.ThrowIfNull(executor);
        return ProcedureCallPipeline<TInput>.Create(dbContext, input).WithExecutor(executor);
    }

    public static ProcedureStreamPipeline<TInput, TRow> ConfigureProcedureStream<TInput, TRow>(
        this IXtraqDbContext dbContext,
        TInput input)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        return ProcedureStreamPipeline<TInput, TRow>.Create(dbContext, input);
    }

    public static ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream> BuildProcedureStream<TInput, TRow, TUpstream>(
        this IXtraqDbContext dbContext,
        TInput input,
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        ArgumentNullException.ThrowIfNull(streamExecutor);
        return ProcedureStreamPipeline<TInput, TRow>.Create(dbContext, input).WithExecutor(streamExecutor);
    }
}

public interface IProcedureExecutionContext
{
    IXtraqDbContext DbContext { get; }
    object? InputValue { get; }
    string? Label { get; }
    IXtraqTransactionOrchestrator TransactionOrchestrator { get; }
}

public readonly record struct ProcedureExecutionContext<TInput>(
    IXtraqDbContext DbContext,
    TInput Input,
    string? Label,
    IXtraqTransactionOrchestrator TransactionOrchestrator) : IProcedureExecutionContext
{
    object? IProcedureExecutionContext.InputValue => Input;
}

public delegate ValueTask<TResult> ProcedureCallDelegate<TInput, TResult>(
    ProcedureExecutionContext<TInput> context,
    CancellationToken cancellationToken);

public interface IProcedureExecutionPolicy
{
    ValueTask<TResult> ExecuteAsync<TInput, TResult>(
        ProcedureExecutionContext<TInput> context,
        ProcedureCallDelegate<TInput, TResult> next,
        CancellationToken cancellationToken);
}

public sealed class ProcedureCallPipeline<TInput>
{
    private readonly IXtraqDbContext _dbContext;
    private readonly TInput _input;
    private readonly string? _label;
    private readonly IReadOnlyList<IProcedureExecutionPolicy> _policies;

    private ProcedureCallPipeline(
        IXtraqDbContext dbContext,
        TInput input,
        string? label,
        IReadOnlyList<IProcedureExecutionPolicy> policies)
    {
        _dbContext = dbContext;
        _input = input;
        _label = label;
        _policies = policies;
    }

    internal static ProcedureCallPipeline<TInput> Create(IXtraqDbContext dbContext, TInput input)
        => new(dbContext, input, null, Array.Empty<IProcedureExecutionPolicy>());

    public ProcedureCallPipeline<TInput> WithLabel(string label)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(label);
        return new ProcedureCallPipeline<TInput>(_dbContext, _input, label, _policies);
    }

    public ProcedureCallPipeline<TInput> WithPolicy(IProcedureExecutionPolicy policy)
    {
        ArgumentNullException.ThrowIfNull(policy);
        return new ProcedureCallPipeline<TInput>(_dbContext, _input, _label, Append(_policies, policy));
    }

    public ProcedureCallPipeline<TInput> WithPolicies(IEnumerable<IProcedureExecutionPolicy> policies)
    {
        ArgumentNullException.ThrowIfNull(policies);
        var current = _policies;
        foreach (var policy in policies)
        {
            ArgumentNullException.ThrowIfNull(policy);
            current = Append(current, policy);
        }

        return new ProcedureCallPipeline<TInput>(_dbContext, _input, _label, current);
    }

    public ProcedureCallPipeline<TInput> WithTransaction()
        => WithPolicy(TransactionScopeExecutionPolicyFactory.Default);

    public ProcedureCallPipeline<TInput> WithTransaction(XtraqTransactionOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromOptions(options));
    }

    public ProcedureCallPipeline<TInput> WithTransaction(Func<IProcedureExecutionContext, XtraqTransactionOptions?> selector)
    {
        ArgumentNullException.ThrowIfNull(selector);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromSelector(selector));
    }

    public ProcedureCallPipeline<TInput> WithTransaction(TransactionOptionsSelector<TInput> selector)
    {
        ArgumentNullException.ThrowIfNull(selector);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromSelector(selector));
    }

    public ProcedureCallExecution<TInput, TResult> WithExecutor<TResult>(
        Func<IXtraqDbContext, TInput, CancellationToken, ValueTask<TResult>> executor)
    {
        ArgumentNullException.ThrowIfNull(executor);
        return new ProcedureCallExecution<TInput, TResult>(
            this,
            (context, cancellationToken) => executor(context.DbContext, context.Input, cancellationToken));
    }

    internal ProcedureExecutionContext<TInput> CreateContext()
    {
        var orchestrator = ResolveTransactionOrchestrator(_dbContext);
        return new ProcedureExecutionContext<TInput>(_dbContext, _input, _label, orchestrator);
    }

    private static IXtraqTransactionOrchestrator ResolveTransactionOrchestrator(IXtraqDbContext dbContext)
    {
        if (dbContext is IXtraqTransactionOrchestratorAccessor accessor)
        {
            var orchestrator = accessor.TransactionOrchestrator;
            if (orchestrator is not null)
            {
                return orchestrator;
            }
        }

        throw new InvalidOperationException("Procedure pipelines require an IXtraqDbContext that provides an IXtraqTransactionOrchestrator via IXtraqTransactionOrchestratorAccessor.");
    }

    internal ProcedureCallDelegate<TInput, TResult> ApplyPolicies<TResult>(ProcedureCallDelegate<TInput, TResult> terminal)
    {
        if (_policies.Count == 0)
        {
            return terminal;
        }

        var composed = terminal;
        for (var index = _policies.Count - 1; index >= 0; index--)
        {
            var policy = _policies[index];
            var next = composed;
            composed = (context, cancellationToken) => policy.ExecuteAsync(context, next, cancellationToken);
        }

        return composed;
    }

    private static IReadOnlyList<IProcedureExecutionPolicy> Append(
        IReadOnlyList<IProcedureExecutionPolicy> source,
        IProcedureExecutionPolicy policy)
    {
        if (source.Count == 0)
        {
            return new[] { policy };
        }

        var items = new IProcedureExecutionPolicy[source.Count + 1];
        for (var i = 0; i < source.Count; i++)
        {
            items[i] = source[i];
        }

        items[^1] = policy;
        return items;
    }
}

public sealed class ProcedureCallExecution<TInput, TCurrent>
{
    private readonly ProcedureCallPipeline<TInput> _pipeline;
    private readonly ProcedureCallDelegate<TInput, TCurrent> _handler;

    internal ProcedureCallExecution(
        ProcedureCallPipeline<TInput> pipeline,
        ProcedureCallDelegate<TInput, TCurrent> handler)
    {
        _pipeline = pipeline;
        _handler = handler;
    }

    public ProcedureCallExecution<TInput, TNext> Select<TNext>(Func<TCurrent, TNext> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureCallExecution<TInput, TNext>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                return projector(current);
            });
    }

    public ProcedureCallExecution<TInput, TNext> SelectAsync<TNext>(
        Func<TCurrent, CancellationToken, ValueTask<TNext>> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureCallExecution<TInput, TNext>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                return await projector(current, cancellationToken).ConfigureAwait(false);
            });
    }

    public ProcedureCallExecution<TInput, TCurrent> Tap(Action<TCurrent> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureCallExecution<TInput, TCurrent>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                observer(current);
                return current;
            });
    }

    public ProcedureCallExecution<TInput, TCurrent> TapAsync(
        Func<TCurrent, CancellationToken, ValueTask> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureCallExecution<TInput, TCurrent>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                await observer(current, cancellationToken).ConfigureAwait(false);
                return current;
            });
    }

    public ValueTask<TCurrent> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var context = _pipeline.CreateContext();
        var handler = _pipeline.ApplyPolicies(_handler);
        return handler(context, cancellationToken);
    }
}

public sealed class ProcedureStreamPipeline<TInput, TRow>
{
    private readonly ProcedureCallPipeline<TInput> _inner;

    private ProcedureStreamPipeline(ProcedureCallPipeline<TInput> inner)
    {
        _inner = inner;
    }

    internal static ProcedureStreamPipeline<TInput, TRow> Create(IXtraqDbContext dbContext, TInput input)
        => new(ProcedureCallPipeline<TInput>.Create(dbContext, input));

    public ProcedureStreamPipeline<TInput, TRow> WithLabel(string label)
        => new(_inner.WithLabel(label));

    public ProcedureStreamPipeline<TInput, TRow> WithPolicy(IProcedureExecutionPolicy policy)
        => new(_inner.WithPolicy(policy));

    public ProcedureStreamPipeline<TInput, TRow> WithPolicies(IEnumerable<IProcedureExecutionPolicy> policies)
        => new(_inner.WithPolicies(policies));

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream> WithExecutor<TUpstream>(
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor)
    {
        ArgumentNullException.ThrowIfNull(streamExecutor);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream>(
            _inner,
            streamExecutor,
            static (context, upstream, _) => new ValueTask<TUpstream>(upstream),
            null);
    }

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction()
        => new(_inner.WithTransaction());

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(XtraqTransactionOptions options)
        => new(_inner.WithTransaction(options));

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(Func<IProcedureExecutionContext, XtraqTransactionOptions?> selector)
        => new(_inner.WithTransaction(selector));

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(TransactionOptionsSelector<TInput> selector)
        => new(_inner.WithTransaction(selector));
}

public sealed class ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>
{
    private readonly ProcedureCallPipeline<TInput> _pipeline;
    private readonly Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> _streamExecutor;
    private readonly Func<ProcedureExecutionContext<TInput>, TUpstream, CancellationToken, ValueTask<TCurrent>> _completion;
    private readonly Func<TRow, CancellationToken, ValueTask>? _rowHandler;

    internal ProcedureStreamExecution(
        ProcedureCallPipeline<TInput> pipeline,
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor,
        Func<ProcedureExecutionContext<TInput>, TUpstream, CancellationToken, ValueTask<TCurrent>> completion,
        Func<TRow, CancellationToken, ValueTask>? rowHandler)
    {
        _pipeline = pipeline;
        _streamExecutor = streamExecutor;
        _completion = completion;
        _rowHandler = rowHandler;
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> ForEach(
        Func<TRow, CancellationToken, ValueTask> handler)
    {
        ArgumentNullException.ThrowIfNull(handler);
        var composed = _rowHandler is null ? handler : Compose(_rowHandler, handler);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>(
            _pipeline,
            _streamExecutor,
            _completion,
            composed);
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> ForEach(Action<TRow> handler)
    {
        ArgumentNullException.ThrowIfNull(handler);
        return ForEach((row, _) =>
        {
            handler(row);
            return ValueTask.CompletedTask;
        });
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> TapCompletion(Action<TCurrent> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return TapCompletionAsync((value, _) =>
        {
            observer(value);
            return ValueTask.CompletedTask;
        });
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> TapCompletionAsync(
        Func<TCurrent, CancellationToken, ValueTask> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>(
            _pipeline,
            _streamExecutor,
            async (context, upstream, cancellationToken) =>
            {
                var current = await _completion(context, upstream, cancellationToken).ConfigureAwait(false);
                await observer(current, cancellationToken).ConfigureAwait(false);
                return current;
            },
            _rowHandler);
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TNext> CompleteWith<TNext>(
        Func<TCurrent, CancellationToken, ValueTask<TNext>> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TNext>(
            _pipeline,
            _streamExecutor,
            async (context, upstream, cancellationToken) =>
            {
                var current = await _completion(context, upstream, cancellationToken).ConfigureAwait(false);
                return await projector(current, cancellationToken).ConfigureAwait(false);
            },
            _rowHandler);
    }

    public async ValueTask<TCurrent> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var context = _pipeline.CreateContext();

        async ValueTask<TCurrent> Terminal(ProcedureExecutionContext<TInput> executionContext, CancellationToken ct)
        {
            static ValueTask Completed(TRow _, CancellationToken cancellationToken)
                => ValueTask.CompletedTask;

            var handler = _rowHandler ?? Completed;
            var upstream = await _streamExecutor(
                executionContext.DbContext,
                executionContext.Input,
                handler,
                ct).ConfigureAwait(false);

            return await _completion(executionContext, upstream, ct).ConfigureAwait(false);
        }

        var composed = _pipeline.ApplyPolicies<TCurrent>(Terminal);
        return await composed(context, cancellationToken).ConfigureAwait(false);
    }

    public ValueTask<IReadOnlyList<TRow>> BufferAsync(CancellationToken cancellationToken = default)
    {
        var buffer = new List<TRow>();
        return ForEach((row, _) =>
        {
            buffer.Add(row);
            return ValueTask.CompletedTask;
        }).CompleteWith((_, cancellationToken) => new ValueTask<IReadOnlyList<TRow>>(buffer)).ExecuteAsync(cancellationToken);
    }

    public ValueTask<TResult> AggregateAsync<TResult>(
        Func<IReadOnlyList<TRow>, TCurrent, TResult> aggregator,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(aggregator);
        var buffer = new List<TRow>();
        return ForEach((row, _) =>
        {
            buffer.Add(row);
            return ValueTask.CompletedTask;
        }).CompleteWith((output, _) => new ValueTask<TResult>(aggregator(buffer, output))).ExecuteAsync(cancellationToken);
    }

    private static Func<TRow, CancellationToken, ValueTask> Compose(
        Func<TRow, CancellationToken, ValueTask> first,
        Func<TRow, CancellationToken, ValueTask> second)
        => async (row, cancellationToken) =>
        {
            await first(row, cancellationToken).ConfigureAwait(false);
            await second(row, cancellationToken).ConfigureAwait(false);
        };
}
