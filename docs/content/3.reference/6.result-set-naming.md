---
title: ResultSet Naming
description: The generator deterministically replaces generic placeholder names (`ResultSet1`, `ResultSet2`, …) with meaningful, table-based names – without any parity requirement with historical output. The resolver is always-on (no feature flag) and optimized for stability over aggressiveness.
---

## When is a rename applied?

A rename happens only if ALL of the following conditions hold:

1. The original name starts with `ResultSet` (generic placeholder)
2. The stored SQL text (`Sql` field in the snapshot) yields an unambiguous base table for that result set (first SELECT / primary FROM source)
3. The proposed name does not collide with an already assigned name in the same procedure

If any condition fails, the generic name is preserved (determinism > aggressive heuristics).

## Examples

| SQL Fragment                                                | Before     | After      | Reason                                                                                         |
| ----------------------------------------------------------- | ---------- | ---------- | ---------------------------------------------------------------------------------------------- |
| `SELECT * FROM dbo.Users`                                   | ResultSet1 | Users      | First base table `Users` detected                                                              |
| `SELECT u.Id, r.Name FROM dbo.Users u JOIN dbo.Roles r ...` | ResultSet1 | Users      | First FROM source wins (not `Roles`)                                                           |
| `SELECT 1 AS X`                                             | ResultSet1 | ResultSet1 | No table → no rename                                                                           |
| `SELECT * FROM #Temp`                                       | ResultSet1 | ResultSet1 | Temporary / non-qualified table ignored                                                        |
| `WITH C AS (SELECT * FROM dbo.Orders) SELECT * FROM C`      | ResultSet1 | Orders     | Planned: derive from CTE base table – currently still generic until CTE support is implemented |

(CTE / complex scenarios still WIP; see roadmap below.)

## Collision handling & duplicates

Previously, on a name collision (another result set from the same base table) no rename occurred. The current behavior:

1. The first occurrence of a base table receives the plain name (`Users`).
2. Additional result sets from the same table are suffixed numerically: `Users1`, `Users2`, …

This preserves determinism while improving clarity over plain `ResultSetX` placeholders.

## Multiple result sets

Each result set is processed independently:

- Different tables: each generic name is replaced with its table name (if resolvable & valid)
- Same table repeated: suffix scheme as above (`Users`, `Users1`, `Users2`)
- Not resolvable / unparsable: generic name (`ResultSetN`) remains

## Non-goals / exclusions

- Dynamic SQL (`EXEC(@sql)`) → ignored (no reliable base table inference)
- Complex UNION / deep CTE cascades → remain generic for now
- JSON outputs (`FOR JSON`) do not influence naming; focus stays on tabular structure

Roadmap tracking for result-set naming now lives in the central checklist ([Roadmap](../roadmap/index.md)).

## Test coverage (status)

Already covered:

- Simple SELECT from base table (rename)
- Duplicate base tables: suffixes (`Users`, `Users1`)
- Multi-result: only resolvable sets renamed
- Unparsable SQL → generic fallback
- Mixed case table names → normalized comparison (case-insensitive)

## Streaming naming convention

Row streaming is now part of the generated surface area. Every non-JSON result set emits a pair of helpers named `StreamResult{Suffix}Async`, where `{Suffix}` mirrors the resolved aggregate property name (`Users`, `Users1`, `OrderItems`, ...). The pattern stays aligned with the collision rules above—duplicate table sources gain numeric suffixes, keeping the streaming API deterministic.

```csharp
await procedure.StreamResultUsersAsync(
	dbContext,
	request,
	async (row, ct) =>
	{
		logger.LogInformation("Downloading {User}", row.Id);
		await auditWriter.WriteAsync(row.Id, ct);
	},
	cancellationToken);
```

Key details:

- The extension lives on both the generated `<ProcedureName>Extensions` (`IXtraqDbContext`) class and the low-level `<ProcedureName>Procedure` (`DbConnection`) wrapper.
- The callback signature is `Func<TResultRow, CancellationToken, ValueTask>` with an overload that accepts `Func<TResultRow, ValueTask>` for convenience.
- Procedures that expose output parameters surface the payload via the task result (`Task<Output?>`); otherwise the method returns a plain `Task`.
- Internally the helpers forward to `ProcedureExecutor.StreamResultSetAsync`, so only the requested result set is streamed and buffered output remains unchanged.

JSON result sets continue to skip streaming while we stabilise their envelope story—it keeps record materialisation consistent and avoids lossy projection of raw JSON payloads.

## FAQ

**Why ignore every JOIN target except the first FROM source?**  
Determinism and uniqueness – multiple candidates could yield unstable names, so only the primary FROM source is used.

**Can I force a specific name?**  
Currently no. A future override / disable metadata hook may be added if needed.

**Does this affect hashing / determinism?**  
Only when the heuristic triggers. Identical SQL produces identical naming, so behavior is deterministic.

---

Status: Stable – updates occur only when the resolver gains new capabilities.
