{{ HEADER }}
#nullable enable
#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
#endif
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace {{ Namespace }};

public static class ProcedurePipelineExtensions
{
    public static ProcedureCallPipeline<TInput> ConfigureProcedure<TInput>(
        this IXtraqDbContext dbContext,
        TInput input)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        return ProcedureCallPipeline<TInput>.Create(dbContext, input);
    }

    public static ProcedureCallExecution<TInput, TResult> BuildProcedure<TInput, TResult>(
        this IXtraqDbContext dbContext,
        TInput input,
        Func<IXtraqDbContext, TInput, CancellationToken, ValueTask<TResult>> executor)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        ArgumentNullException.ThrowIfNull(executor);
        return ProcedureCallPipeline<TInput>.Create(dbContext, input).WithExecutor(executor);
    }

    public static ProcedureStreamPipeline<TInput, TRow> ConfigureProcedureStream<TInput, TRow>(
        this IXtraqDbContext dbContext,
        TInput input)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        return ProcedureStreamPipeline<TInput, TRow>.Create(dbContext, input);
    }

    public static ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream> BuildProcedureStream<TInput, TRow, TUpstream>(
        this IXtraqDbContext dbContext,
        TInput input,
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor)
    {
        ArgumentNullException.ThrowIfNull(dbContext);
        ArgumentNullException.ThrowIfNull(streamExecutor);
        return ProcedureStreamPipeline<TInput, TRow>.Create(dbContext, input).WithExecutor(streamExecutor);
    }
}

#if NET8_0_OR_GREATER && XTRAQ_MINIMAL_API

public static class ProcedureRouteHandlerBuilderExtensions
{
    public static RouteHandlerBuilder WithProcedure<TInput, TResult>(
        this RouteHandlerBuilder builder,
        Func<ProcedureCallPipeline<TInput>, ProcedureCallExecution<TInput, TResult>> configure,
        Func<TResult, HttpContext, CancellationToken, ValueTask<IResult>>? responseWriter = null)
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(configure);

        builder.AddEndpointFilter(new ProcedurePipelineEndpointFilter<TInput, TResult>(configure, responseWriter));
        return builder;
    }

    public static RouteHandlerBuilder WithProcedureStream<TInput, TRow, TUpstream, TResult>(
        this RouteHandlerBuilder builder,
        Func<ProcedureStreamPipeline<TInput, TRow>, ProcedureStreamExecution<TInput, TRow, TUpstream, TResult>> configure,
        Func<IAsyncEnumerable<TRow>, Task<TResult>, HttpContext, CancellationToken, ValueTask<IResult>>? responseWriter = null)
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(configure);

        builder.AddEndpointFilter(new ProcedureStreamEndpointFilter<TInput, TRow, TUpstream, TResult>(configure, responseWriter));
        return builder;
    }

    private sealed class ProcedurePipelineEndpointFilter<TInput, TResult> : IEndpointFilter
    {
        private readonly Func<ProcedureCallPipeline<TInput>, ProcedureCallExecution<TInput, TResult>> _configure;
        private readonly Func<TResult, HttpContext, CancellationToken, ValueTask<IResult>> _responseWriter;

        public ProcedurePipelineEndpointFilter(
            Func<ProcedureCallPipeline<TInput>, ProcedureCallExecution<TInput, TResult>> configure,
            Func<TResult, HttpContext, CancellationToken, ValueTask<IResult>>? responseWriter)
        {
            _configure = configure ?? throw new ArgumentNullException(nameof(configure));
            _responseWriter = responseWriter ?? DefaultWriter;
        }

        public async ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next)
        {
            ArgumentNullException.ThrowIfNull(context);

            var httpContext = context.HttpContext;
            var dbContext = httpContext.RequestServices.GetRequiredService<IXtraqDbContext>();
            var input = ResolveInput(context);
            var pipeline = ProcedureCallPipeline<TInput>.Create(dbContext, input);
            var execution = _configure(pipeline) ?? throw new InvalidOperationException("Procedure pipeline configuration returned null execution.");

            var cancellationToken = ResolveCancellationToken(context, httpContext.RequestAborted);
            var result = await execution.ExecuteAsync(cancellationToken).ConfigureAwait(false);
            return await _responseWriter(result, httpContext, cancellationToken).ConfigureAwait(false);
        }

        private static TInput ResolveInput(EndpointFilterInvocationContext context)
        {
            for (var index = 0; index < context.Arguments.Count; index++)
            {
                if (context.Arguments[index] is TInput typed)
                {
                    return typed;
                }
            }

            throw new InvalidOperationException($"Route handler must expose a parameter of type '{typeof(TInput).FullName}'.");
        }

        private static CancellationToken ResolveCancellationToken(EndpointFilterInvocationContext context, CancellationToken fallback)
        {
            for (var index = 0; index < context.Arguments.Count; index++)
            {
                if (context.Arguments[index] is CancellationToken token)
                {
                    return token;
                }
            }

            return fallback;
        }

        private static ValueTask<IResult> DefaultWriter(TResult result, HttpContext httpContext, CancellationToken cancellationToken)
        {
            if (result is IResult direct)
            {
                return ValueTask.FromResult(direct);
            }

            return ValueTask.FromResult<IResult>(Results.Ok(result));
        }
    }

    private sealed class ProcedureStreamEndpointFilter<TInput, TRow, TUpstream, TResult> : IEndpointFilter
    {
        private static readonly JsonSerializerOptions NdjsonSerializerOptions = new(JsonSerializerDefaults.Web);
        private readonly Func<ProcedureStreamPipeline<TInput, TRow>, ProcedureStreamExecution<TInput, TRow, TUpstream, TResult>> _configure;
        private readonly Func<IAsyncEnumerable<TRow>, Task<TResult>, HttpContext, CancellationToken, ValueTask<IResult>> _responseWriter;

        public ProcedureStreamEndpointFilter(
            Func<ProcedureStreamPipeline<TInput, TRow>, ProcedureStreamExecution<TInput, TRow, TUpstream, TResult>> configure,
            Func<IAsyncEnumerable<TRow>, Task<TResult>, HttpContext, CancellationToken, ValueTask<IResult>>? responseWriter)
        {
            _configure = configure ?? throw new ArgumentNullException(nameof(configure));
            _responseWriter = responseWriter ?? DefaultWriter;
        }

        public async ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next)
        {
            ArgumentNullException.ThrowIfNull(context);

            var httpContext = context.HttpContext;
            var dbContext = httpContext.RequestServices.GetRequiredService<IXtraqDbContext>();
            var input = ResolveInput(context);
            var pipeline = ProcedureStreamPipeline<TInput, TRow>.Create(dbContext, input);
            var execution = _configure(pipeline) ?? throw new InvalidOperationException("Procedure stream pipeline configuration returned null execution.");

            var cancellationToken = ResolveCancellationToken(context, httpContext.RequestAborted);
            var channel = System.Threading.Channels.Channel.CreateBounded<TRow>(new System.Threading.Channels.BoundedChannelOptions(64)
            {
                SingleReader = true,
                SingleWriter = false,
                FullMode = System.Threading.Channels.BoundedChannelFullMode.Wait,
                AllowSynchronousContinuations = false
            });

            var streamingExecution = execution.ForEach((row, token) => WriteRowAsync(channel.Writer, row, token));
            var completionTask = ExecutePipelineAsync(streamingExecution, channel.Writer, cancellationToken);

            var rows = ReadChannel(channel.Reader, cancellationToken);
            var response = await _responseWriter(rows, completionTask, httpContext, cancellationToken).ConfigureAwait(false);

            if (!completionTask.IsCompleted)
            {
                await completionTask.ConfigureAwait(false);
            }

            return response;
        }

        private static TInput ResolveInput(EndpointFilterInvocationContext context)
        {
            for (var index = 0; index < context.Arguments.Count; index++)
            {
                if (context.Arguments[index] is TInput typed)
                {
                    return typed;
                }
            }

            throw new InvalidOperationException($"Route handler must expose a parameter of type '{typeof(TInput).FullName}'.");
        }

        private static CancellationToken ResolveCancellationToken(EndpointFilterInvocationContext context, CancellationToken fallback)
        {
            for (var index = 0; index < context.Arguments.Count; index++)
            {
                if (context.Arguments[index] is CancellationToken token)
                {
                    return token;
                }
            }

            return fallback;
        }

        private static async Task<TResult> ExecutePipelineAsync(
            ProcedureStreamExecution<TInput, TRow, TUpstream, TResult> execution,
            System.Threading.Channels.ChannelWriter<TRow> writer,
            CancellationToken cancellationToken)
        {
            Exception? failure = null;
            try
            {
                return await execution.ExecuteAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                failure = ex;
                throw;
            }
            finally
            {
                writer.TryComplete(failure);
            }
        }

        private static ValueTask WriteRowAsync(System.Threading.Channels.ChannelWriter<TRow> writer, TRow row, CancellationToken cancellationToken)
        {
            if (writer.TryWrite(row))
            {
                return ValueTask.CompletedTask;
            }

            return writer.WriteAsync(row, cancellationToken);
        }

        private static async IAsyncEnumerable<TRow> ReadChannel(
            System.Threading.Channels.ChannelReader<TRow> reader,
            [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)
        {
            while (await reader.WaitToReadAsync(cancellationToken).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    yield return item;
                }
            }
        }

        private static async ValueTask<IResult> DefaultWriter(
            IAsyncEnumerable<TRow> rows,
            Task<TResult> completionTask,
            HttpContext httpContext,
            CancellationToken cancellationToken)
        {
            var response = httpContext.Response;
            response.StatusCode = StatusCodes.Status200OK;
            response.ContentType ??= "application/x-ndjson";

            await foreach (var row in rows.WithCancellation(cancellationToken).ConfigureAwait(false))
            {
                var json = JsonSerializer.Serialize(row, NdjsonSerializerOptions);
                await response.WriteAsync(json, cancellationToken).ConfigureAwait(false);
                await response.WriteAsync("\n", cancellationToken).ConfigureAwait(false);
                await response.Body.FlushAsync(cancellationToken).ConfigureAwait(false);
            }

            await completionTask.ConfigureAwait(false);
            return Results.Empty;
        }
    }
}

#endif

public interface IProcedureExecutionContext
{
    IXtraqDbContext DbContext { get; }
    object? InputValue { get; }
    string? Label { get; }
    IXtraqTransactionOrchestrator TransactionOrchestrator { get; }
}

public readonly record struct ProcedureExecutionContext<TInput>(
    IXtraqDbContext DbContext,
    TInput Input,
    string? Label,
    IXtraqTransactionOrchestrator TransactionOrchestrator) : IProcedureExecutionContext
{
    object? IProcedureExecutionContext.InputValue => Input;
}

public delegate ValueTask<TResult> ProcedureCallDelegate<TInput, TResult>(
    ProcedureExecutionContext<TInput> context,
    CancellationToken cancellationToken);

public interface IProcedureExecutionPolicy
{
    ValueTask<TResult> ExecuteAsync<TInput, TResult>(
        ProcedureExecutionContext<TInput> context,
        ProcedureCallDelegate<TInput, TResult> next,
        CancellationToken cancellationToken);
}

public sealed class ProcedureCallPipeline<TInput>
{
    private readonly IXtraqDbContext _dbContext;
    private readonly TInput _input;
    private readonly string? _label;
    private readonly IReadOnlyList<IProcedureExecutionPolicy> _policies;

    private ProcedureCallPipeline(
        IXtraqDbContext dbContext,
        TInput input,
        string? label,
        IReadOnlyList<IProcedureExecutionPolicy> policies)
    {
        _dbContext = dbContext;
        _input = input;
        _label = label;
        _policies = policies;
    }

    internal static ProcedureCallPipeline<TInput> Create(IXtraqDbContext dbContext, TInput input)
        => new(dbContext, input, null, Array.Empty<IProcedureExecutionPolicy>());

    public ProcedureCallPipeline<TInput> WithLabel(string label)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(label);
        return new ProcedureCallPipeline<TInput>(_dbContext, _input, label, _policies);
    }

    public ProcedureCallPipeline<TInput> WithPolicy(IProcedureExecutionPolicy policy)
    {
        ArgumentNullException.ThrowIfNull(policy);
        return new ProcedureCallPipeline<TInput>(_dbContext, _input, _label, Append(_policies, policy));
    }

    public ProcedureCallPipeline<TInput> WithPolicies(IEnumerable<IProcedureExecutionPolicy> policies)
    {
        ArgumentNullException.ThrowIfNull(policies);
        var current = _policies;
        foreach (var policy in policies)
        {
            ArgumentNullException.ThrowIfNull(policy);
            current = Append(current, policy);
        }

        return new ProcedureCallPipeline<TInput>(_dbContext, _input, _label, current);
    }

    public ProcedureCallPipeline<TInput> WithTransaction()
        => WithPolicy(TransactionScopeExecutionPolicyFactory.Default);

    public ProcedureCallPipeline<TInput> WithTransaction(XtraqTransactionOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromOptions(options));
    }

    public ProcedureCallPipeline<TInput> WithTransaction(Func<IProcedureExecutionContext, XtraqTransactionOptions?> selector)
    {
        ArgumentNullException.ThrowIfNull(selector);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromSelector(selector));
    }

    public ProcedureCallPipeline<TInput> WithTransaction(TransactionOptionsSelector<TInput> selector)
    {
        ArgumentNullException.ThrowIfNull(selector);
        return WithPolicy(TransactionScopeExecutionPolicyFactory.FromSelector(selector));
    }

    public ProcedureCallExecution<TInput, TResult> WithExecutor<TResult>(
        Func<IXtraqDbContext, TInput, CancellationToken, ValueTask<TResult>> executor)
    {
        ArgumentNullException.ThrowIfNull(executor);
        return new ProcedureCallExecution<TInput, TResult>(
            this,
            (context, cancellationToken) => executor(context.DbContext, context.Input, cancellationToken));
    }

    internal ProcedureExecutionContext<TInput> CreateContext()
    {
        var orchestrator = ResolveTransactionOrchestrator(_dbContext);
        return new ProcedureExecutionContext<TInput>(_dbContext, _input, _label, orchestrator);
    }

    private static IXtraqTransactionOrchestrator ResolveTransactionOrchestrator(IXtraqDbContext dbContext)
    {
        if (dbContext is IXtraqTransactionOrchestratorAccessor accessor)
        {
            var orchestrator = accessor.TransactionOrchestrator;
            if (orchestrator is not null)
            {
                return orchestrator;
            }
        }

        throw new InvalidOperationException("Procedure pipelines require an IXtraqDbContext that provides an IXtraqTransactionOrchestrator via IXtraqTransactionOrchestratorAccessor.");
    }

    internal ProcedureCallDelegate<TInput, TResult> ApplyPolicies<TResult>(ProcedureCallDelegate<TInput, TResult> terminal)
    {
        if (_policies.Count == 0)
        {
            return terminal;
        }

        var composed = terminal;
        for (var index = _policies.Count - 1; index >= 0; index--)
        {
            var policy = _policies[index];
            var next = composed;
            composed = (context, cancellationToken) => policy.ExecuteAsync(context, next, cancellationToken);
        }

        return composed;
    }

    private static IReadOnlyList<IProcedureExecutionPolicy> Append(
        IReadOnlyList<IProcedureExecutionPolicy> source,
        IProcedureExecutionPolicy policy)
    {
        if (source.Count == 0)
        {
            return new[] { policy };
        }

        var items = new IProcedureExecutionPolicy[source.Count + 1];
        for (var i = 0; i < source.Count; i++)
        {
            items[i] = source[i];
        }

        items[^1] = policy;
        return items;
    }
}

public sealed class ProcedureCallExecution<TInput, TCurrent>
{
    private readonly ProcedureCallPipeline<TInput> _pipeline;
    private readonly ProcedureCallDelegate<TInput, TCurrent> _handler;

    internal ProcedureCallExecution(
        ProcedureCallPipeline<TInput> pipeline,
        ProcedureCallDelegate<TInput, TCurrent> handler)
    {
        _pipeline = pipeline;
        _handler = handler;
    }

    public ProcedureCallExecution<TInput, TNext> Select<TNext>(Func<TCurrent, TNext> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureCallExecution<TInput, TNext>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                return projector(current);
            });
    }

    public ProcedureCallExecution<TInput, TNext> SelectAsync<TNext>(
        Func<TCurrent, CancellationToken, ValueTask<TNext>> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureCallExecution<TInput, TNext>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                return await projector(current, cancellationToken).ConfigureAwait(false);
            });
    }

    public ProcedureCallExecution<TInput, TCurrent> Tap(Action<TCurrent> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureCallExecution<TInput, TCurrent>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                observer(current);
                return current;
            });
    }

    public ProcedureCallExecution<TInput, TCurrent> TapAsync(
        Func<TCurrent, CancellationToken, ValueTask> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureCallExecution<TInput, TCurrent>(
            _pipeline,
            async (context, cancellationToken) =>
            {
                var current = await _handler(context, cancellationToken).ConfigureAwait(false);
                await observer(current, cancellationToken).ConfigureAwait(false);
                return current;
            });
    }

    public ValueTask<TCurrent> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var context = _pipeline.CreateContext();
        var handler = _pipeline.ApplyPolicies(_handler);
        return handler(context, cancellationToken);
    }
}

public sealed class ProcedureStreamPipeline<TInput, TRow>
{
    private readonly ProcedureCallPipeline<TInput> _inner;

    private ProcedureStreamPipeline(ProcedureCallPipeline<TInput> inner)
    {
        _inner = inner;
    }

    internal static ProcedureStreamPipeline<TInput, TRow> Create(IXtraqDbContext dbContext, TInput input)
        => new(ProcedureCallPipeline<TInput>.Create(dbContext, input));

    public ProcedureStreamPipeline<TInput, TRow> WithLabel(string label)
        => new(_inner.WithLabel(label));

    public ProcedureStreamPipeline<TInput, TRow> WithPolicy(IProcedureExecutionPolicy policy)
        => new(_inner.WithPolicy(policy));

    public ProcedureStreamPipeline<TInput, TRow> WithPolicies(IEnumerable<IProcedureExecutionPolicy> policies)
        => new(_inner.WithPolicies(policies));

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream> WithExecutor<TUpstream>(
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor)
    {
        ArgumentNullException.ThrowIfNull(streamExecutor);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TUpstream>(
            _inner,
            streamExecutor,
            static (context, upstream, _) => new ValueTask<TUpstream>(upstream),
            null);
    }

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction()
        => new(_inner.WithTransaction());

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(XtraqTransactionOptions options)
        => new(_inner.WithTransaction(options));

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(Func<IProcedureExecutionContext, XtraqTransactionOptions?> selector)
        => new(_inner.WithTransaction(selector));

    public ProcedureStreamPipeline<TInput, TRow> WithTransaction(TransactionOptionsSelector<TInput> selector)
        => new(_inner.WithTransaction(selector));
}

public sealed class ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>
{
    private readonly ProcedureCallPipeline<TInput> _pipeline;
    private readonly Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> _streamExecutor;
    private readonly Func<ProcedureExecutionContext<TInput>, TUpstream, CancellationToken, ValueTask<TCurrent>> _completion;
    private readonly Func<TRow, CancellationToken, ValueTask>? _rowHandler;

    internal ProcedureStreamExecution(
        ProcedureCallPipeline<TInput> pipeline,
        Func<IXtraqDbContext, TInput, Func<TRow, CancellationToken, ValueTask>, CancellationToken, ValueTask<TUpstream>> streamExecutor,
        Func<ProcedureExecutionContext<TInput>, TUpstream, CancellationToken, ValueTask<TCurrent>> completion,
        Func<TRow, CancellationToken, ValueTask>? rowHandler)
    {
        _pipeline = pipeline;
        _streamExecutor = streamExecutor;
        _completion = completion;
        _rowHandler = rowHandler;
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> ForEach(
        Func<TRow, CancellationToken, ValueTask> handler)
    {
        ArgumentNullException.ThrowIfNull(handler);
        var composed = _rowHandler is null ? handler : Compose(_rowHandler, handler);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>(
            _pipeline,
            _streamExecutor,
            _completion,
            composed);
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> ForEach(Action<TRow> handler)
    {
        ArgumentNullException.ThrowIfNull(handler);
        return ForEach((row, _) =>
        {
            handler(row);
            return ValueTask.CompletedTask;
        });
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> TapCompletion(Action<TCurrent> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return TapCompletionAsync((value, _) =>
        {
            observer(value);
            return ValueTask.CompletedTask;
        });
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent> TapCompletionAsync(
        Func<TCurrent, CancellationToken, ValueTask> observer)
    {
        ArgumentNullException.ThrowIfNull(observer);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TCurrent>(
            _pipeline,
            _streamExecutor,
            async (context, upstream, cancellationToken) =>
            {
                var current = await _completion(context, upstream, cancellationToken).ConfigureAwait(false);
                await observer(current, cancellationToken).ConfigureAwait(false);
                return current;
            },
            _rowHandler);
    }

    public ProcedureStreamExecution<TInput, TRow, TUpstream, TNext> CompleteWith<TNext>(
        Func<TCurrent, CancellationToken, ValueTask<TNext>> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        return new ProcedureStreamExecution<TInput, TRow, TUpstream, TNext>(
            _pipeline,
            _streamExecutor,
            async (context, upstream, cancellationToken) =>
            {
                var current = await _completion(context, upstream, cancellationToken).ConfigureAwait(false);
                return await projector(current, cancellationToken).ConfigureAwait(false);
            },
            _rowHandler);
    }

    public async ValueTask<TCurrent> ExecuteAsync(CancellationToken cancellationToken = default)
    {
        var context = _pipeline.CreateContext();

        async ValueTask<TCurrent> Terminal(ProcedureExecutionContext<TInput> executionContext, CancellationToken ct)
        {
            static ValueTask Completed(TRow _, CancellationToken cancellationToken)
                => ValueTask.CompletedTask;

            var handler = _rowHandler ?? Completed;
            var upstream = await _streamExecutor(
                executionContext.DbContext,
                executionContext.Input,
                handler,
                ct).ConfigureAwait(false);

            return await _completion(executionContext, upstream, ct).ConfigureAwait(false);
        }

        var composed = _pipeline.ApplyPolicies<TCurrent>(Terminal);
        return await composed(context, cancellationToken).ConfigureAwait(false);
    }

    public ValueTask<IReadOnlyList<TRow>> BufferAsync(CancellationToken cancellationToken = default)
    {
        var buffer = new List<TRow>();
        return ForEach((row, _) =>
        {
            buffer.Add(row);
            return ValueTask.CompletedTask;
        }).CompleteWith((_, cancellationToken) => new ValueTask<IReadOnlyList<TRow>>(buffer)).ExecuteAsync(cancellationToken);
    }

    public ValueTask<TResult> AggregateAsync<TResult>(
        Func<IReadOnlyList<TRow>, TCurrent, TResult> aggregator,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(aggregator);
        var buffer = new List<TRow>();
        return ForEach((row, _) =>
        {
            buffer.Add(row);
            return ValueTask.CompletedTask;
        }).CompleteWith((output, _) => new ValueTask<TResult>(aggregator(buffer, output))).ExecuteAsync(cancellationToken);
    }

    private static Func<TRow, CancellationToken, ValueTask> Compose(
        Func<TRow, CancellationToken, ValueTask> first,
        Func<TRow, CancellationToken, ValueTask> second)
        => async (row, cancellationToken) =>
        {
            await first(row, cancellationToken).ConfigureAwait(false);
            await second(row, cancellationToken).ConfigureAwait(false);
        };
}
